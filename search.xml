<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[六省联考2017 题解汇总]]></title>
    <url>%2Fblog%2F%E5%85%AD%E7%9C%81%E8%81%94%E8%80%832017-%E9%A2%98%E8%A7%A3%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[--- title: 六省联考2017 题解汇总 tags: [数论, 网络流] categories: solution date: 2020-06-06 11:55:39 password: --- 题面自己找找，loj 和洛谷上都有。 # Day1 ## T1 期末考试 按照题意模拟。 ## T2 相逢是问候 首先模数不是质数，所以要用扩展欧拉定理来对幂取模。 扩展欧拉定理是需要讨论指数是小于 $\varphi (p)$ 还是大于等于的，需要比较麻烦的特判。 如果手玩的话会发现这么一件事情：对于 $c ^{c ^{c ^{c ^{\cdots}}}}$ 这个式子而言，嵌套到了一定的层数之后这个式子的值在模意义下不会再改变（因为每次都会让上层应用上欧拉定理，而 $\varphi (\varphi(\varphi(p)))$ 在嵌套多次后会变成 $1$）。 众所周知的是 $\varphi(n)$ 这个函数嵌套 $\log n$ 层就会变成 $1$。证明不展开了，分奇偶讨论即可。 这样的话整个序列的势能是一定的，考虑用并查集跳过那些已经到达界，修改不再变化的点，每次暴力修改即可。 由于层数 $\log n$ 层，每次修改需要 $O(\log n)$ 的快速幂，还有 $\log n$ 次修改，总复杂度 $O(n \log ^3 n)$。由于模数很少，且都是 $\varphi$ 嵌套的形式，考虑预处理好他们的根号次幂，光速幂即可做到 $O(n \log ^2 n)$。实际上直接将阈值设成 $6$ 就可以很快的跑过了。 ## T3 组合数问题 可能这就是菜鸡的水平吧……这题没做出来。 考虑要求的式子的组合意义，相当于是在 $nk$ 个数中选出个数模 $k$ 为 $r$ 的方案数。考虑组合数的原始式子，即 $f _{i, j} = f _{i - 1, j - 1} + f _{i - 1, j}$，发现这个式子放到模 $k$ 意义下就可以做出来了，直接矩幂 $O(k ^3 \log n)$。 也可以考虑倍增 DP，也即 $f _{2n, i + j} \gets f _{n, i} f _{n, j}$，可以理解成讨论前 $n$ 和后 $n$ 个的选取情况。暴力卷积复杂度 $O(k ^2 \log n)$。 当然这里也可以用生成函数的方式来解释这个倍增 DP。可以去看洛谷上的题解。 # Day2 ## T1 摧毁树状图 坑分类讨论题。 首先连通块数等于点数减边数，也就相当于找到两条链使得边数减点数最大。 先踢掉两条链相交于一点的情况不考虑，考虑不相交的情况。可以发现对于一个子树而言答案有 4 种情况： 1. 答案不经过根，展开得到两种。 2. 答案经过根，展开得到两种，并且还要求出一个点到其子树内延伸一条链加上其子树内另一条链的最大值。这个也要讨论起来维护。 相交的就枚举交点，两条链要么出子树要么不出。如果出了就换根一下得到到子树外的链的最优答案，没出就相当于选四个最大的链拼起来。 注意一个很坑的地方。一开始自己推的式子是对于两条单独的链而言的，为 $\sum _{i = 1} ^m d _i - 2m + 1$。但是在两条链有公共边（指的是每个点连出去的边）的情况下，把这个式子加起来的时侯要减 $1$，三条链减 $2$，依此类推。要着重注意这种情况的判断。 可以做到 $O(n)$，偷懒用了 `std::multiset` 变成了 $O(n \log n)$。~~这种 shit 题考场上真的码的完吗~~ ## T2 分手是祝愿 首先要发现一个很重要的性质：如果将按下每个灯所带来的影响写成一个长度为 $n$ 的 $01$ 向量，可以发现这些向量是线性无关的，也就是按一个灯不能被其他灯的组合表示出来。 要证明倒是很简单。容易知道任意长度为 $n$ 的 $01$ 序列都可以被他们表示出来，考虑如下方式： > 从后往前遍历，遇到 $0$ 不管，遇到 $1$ 将其约数位置异或上 $1$。 于是他们的张成大小为 $O(2 ^n)$，又因为只有 $n$ 个向量，所以这 $n$ 个向量一定线性无关。 由此也可以得到这个方式得出来的就是最小的操作次数。于是设 $f _i$ 表示一个要操作 $i$ 次的序列，期望要多少次才能到 $i - 1$ 次的序列。有转移： $$ f _i = \frac i n + \frac {n - i} n (f _i + f _{i + 1} + 1) $$ 移项之后递推即可。$O(n \log n)$，因为要枚举约数算出一开始的序列的操作次数。 ## T3 寿司餐厅 好像是一道偏简单的网络流？本来因为 T1 的关系看这题的时间就很少，加上对网络流不熟练，打个暴力走人还算正常。 需要注意到题意里面一些特别诡异的地方：每个收益只会被获得一次，每个点的代价也只会被消耗一次，再加上这些权值正负不定，这些条件直接把 DP 限制死了。 看到数据范围，可以考虑用网络流来解决这个问题。 先考虑抽象出来一个模型。可以发现，如果选择了一个区间 $[i, j]$，那么其子区间内的收益和代价都会被选中，可以回忆起一个重要的模型：最大权闭合子图。 > 最大权闭合子图：给定一个 $n$ 点 $m$ 边的有向图，点有点权，选出一个点集，满足这个点集的所有出边所指向的点都在点集内（也就是「闭合」子图），最大化选的点权和。 > > 最优的情况是将大于 $0$ 的点权全部选中，但是这种方案不一定合法。考虑用最小割来调整最优方案。 > > 如果一个点点权小于 $0$，向汇点 $T$ 连流量为 $-a _i$ 的边；否则从源点向其连流量为 $a _i$ 的边。割掉了分别表示不选和选。其他的边建流量为 INF 的边，表示不准割。 > > 用所有大于 $0$ 的点权减去最小割就是答案。 每一个区间都代表一个点，$[i, j]$ 向 $[i + 1, j], [i, j - 1]$ 连边表示强制选择，然后 $[i, i]$ 单独向 $a _i$ 这个类型连边，因为 $a _i$ 这个类型被选会单独带来 $a _i ^2$ 的代价。 然后跑最大权闭合子图即可。]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日插值法]]></title>
    <url>%2Fblog%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95%2F</url>
    <content type="text"><![CDATA[--- title: 拉格朗日插值法 tags: [插值] categories: summary date: 2020-06-06 11:54:47 password: --- 拉格朗日插值法用来在 $O(n ^2)$ 的时间内解决已知多项式点值表达求系数表达的问题。 给定 $n$ 个点 $(x _1, y _1), \dots, (x _n, y _n)$，求出这 $n$ 个点确定的一个 $n - 1$ 次的多项式。 拉格朗日插值法基于这样一个思路：考虑构造出 $n$ 个函数 $f _1(x), f _2(x), \cdots, f _n(x)$，让 $f _i(x)$ 在 $x _i$ 处取值为 $1$，其余处取值为 $0$，最后将这 $n$ 个函数分别乘上 $y _i$ 再加起来就可以得到要求的多项式。 有了这个基本思路，那么 $f _i(x)$ 也不难构造： $$ f _i(x) = \prod _{j \not = i} \frac {x - x _j} {x _i - x _j} $$ 容易验证，代入 $x _i$ 时式子值为 $1$，其他的则为 $0$。 所以可以得到最终的式子： $$ f(x) = \sum _{i = 1} ^n y _i \prod _{j \not = i} \frac {x - x _j} {x _i - x _j} $$ 易见复杂度为 $O(n ^2)$。 如果要插系数的话也不难。首先系数可以通过把 $y _i f _i(x)$ 的系数相加得到，所以这里只讲 $f _i(x)$ 的系数怎么求。 观察式子： $$ f _i(x) = \prod _{j \not = i} \frac {x - x _j} {x _i - x _j} $$ 分母容易算，可以发现分子都是 $\prod _{j = 1} ^n (x - x _j)$ 除掉 $x - x _i$ 的形式。那么先将 $\prod _{j = 1} ^n (x - x _j)$ 的系数 $O(n ^2)$ 地暴力乘出来，然后直接对 $x - x _i$ 做一遍多项式除法就可以得到 $f _i(x)$ 的系数表达。每次做是 $O(n)$ 的，有 $n$ 个 $f _i(x)$，故总复杂度仍为 $O(n ^2)$。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成函数入门]]></title>
    <url>%2Fblog%2F%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[--- title: 生成函数入门 tags: [生成函数, 多项式] categories: summary date: 2020-06-06 11:54:13 password: --- 比较严谨的东西就略过了，这里讲的主要是做题要用到的一些技巧。 这里个人认为生成函数的卷积本质上都是枚举了划分，有标号则需要组合数来分配标号（若这些物品本质一样，需要除掉阶乘），无标号不管。 # OGF $$ A(x) = \sum _{n \ge 0} a _n x ^n \\\\ h _n = \sum _{i = 0} ^n f _i g _{n - i} \Leftrightarrow H(x) = F(x) G(x) $$ 一些常用的表达式： $$ [x ^m] \frac 1 {(1 - x) ^n} = {n + m - 1 \choose n - 1} \\\\ [x ^m] (1 + x) ^n = {n \choose m} \\\\ \ln (1 + x) = \sum _{n \ge 1} \frac {(-1)^{n+1}} n x ^n $$ 最后一个就是泰勒级数。 一些需要熟练的操作： 1. 换元和移项。乘上 $x$ 或者求导积分是移项的两种方法，求导积分会额外带系数。 2. 爆推式子然后转封闭形式。~~也就是要直接盯生成函数把封闭形式盯出来~~ 3. 求一些数列的通项。 ## 付公主的背包 > $n$ 个物品，每个物品有无限个，体积为 $v _i \in [1, m]$。 > > 问总体积分别为 $1, \cdots, m$ 的方案数。 > > $n, m \le 10 ^5$ 暴力就硬背包，$O(nm)$ 的。 实际上看到背包就要想到生成函数。玩了一下发现每个物品的生成函数是 $$ \sum _{n \ge 0} \left[ v _i | n \right] x ^n = \frac 1 {1 - x ^{v _i}} $$ 那么做背包相当于把生成函数全部卷积起来，令答案的生成函数为 $A(x)$： $$ A(x) = \prod _{i = 1} ^n \frac 1 {1 - x^{v _i}} $$ 乘积不好处理，比较套路的想到先取 $\ln$ 再取 $\exp$： $$ A(x) = \exp \left (\sum _{i = 1} ^n \ln \left (\frac 1 {1 - x ^{v _i}} \right) \right) $$ 回忆一下 $\ln \frac 1 {(1 + t)} = - \ln (1+t)$ 的泰勒展开式，将 $t = (-x) ^{v _i}$ 代入得到 $$ \ln \left (\frac 1 {1 - x ^{v _i}} \right) = \sum _{n \ge 1} [v _i | n] \frac {v _i} n x ^n $$ 注意这里是 $n \ge 1$，因为取 $\ln$ 后常数项变为 $0$。 推到这里的时侯发现已经可以算了：对于每个 $v _i$ 枚举其倍数去作贡献，可以 $O(n \log n)$ 地得到将 $\ln$ 求和的结果。 把这个式子 $\exp$ 回去即可，复杂度 $O(n \log n)$。 整数划分同理，只是物品是满的而已。 ## 生成树 > $n$ 个点的完全图，定义形如 $(i, i + 1)$ 的边为特殊边，以及一个有 $x$ 条特殊边的生成树的权值为 $\varphi (x)$。求所有生成树价值的和。 > > $n \le 10 ^6$ 先填上特殊边再考虑方案数。 直接上 $\rm Prufer$ 序的一个定理： - *$n$ 个点 $m$ 个连通块的无向图，将这些连通块连通起来的选边的方案数是 $n ^{m - 2} \prod _{i = 1} ^m s _i$，其中 $s _i$ 为第 $i$ 个连通块的大小*。 由于连通块数等于点数减边数，直接枚举连通块数算钦定了 $m$ 个连通块的方案数，最后二项式反演一下就可以了。 $n ^{m - 2}$ 暂且不管，主要是求后面的 $\prod$ 的部分。 考虑一个连通块的生成函数为 $$ F(x) = \sum _{n \ge 1} n x ^n = \frac x {(1 - x)^2} $$ *这里的连通块指的是连续的区间，所以应当为 OGF*。 $m$ 个连通块相当于是这个函数的 $m$ 次方，于是 $$ [x ^n] \left (F(x)\right) ^m = [x ^n] \frac {x ^m} {(1 - x)^{2m}} = {m + n - 1 \choose 2m - 1} $$ 没了。 ## 猎人杀 > $n$ 个猎人，每个猎人有仇恨值 $w _i$，每个猎人死后，会有 $\dfrac {w _i} {\sum _{\text{j is alive}} {w _j}}$ 的概率打掉猎人 $i$。求 $1$ 号猎人最后死亡的概率。 > > $\sum w _i \le 10 ^5$ *下面可能会用 $w(S)$ 表示 $\sum _{i \in S} w_i$*。 首先要去除打了一个猎人后所带来的概率的后效性。 **上面这个策略打到 $i$ 的概率等价于「不断开枪，可以打死的人，直至打中活的人」这个策略打到 $i$ 的概率**。这是个很重要的转化。 于是开始转移。先设 $f(S)$ 表示钦定了 $S$ 集合内的人全部晚于 $1$ 号猎人死的概率。答案为 $\sum _{1 \not \in S} (-1) ^{|S|} f(S)$。 有转移方程（$U$ 指全集）： $$ f(S) = \frac {w _1} {w(U)} + \frac {w(U) - w(S) - w _1} {w(U)} f(S) $$ 打中 $1$ 结束，打中 $S$ 非法，打中 $S$ 和 $1$ 之外的不变。 移下项得到 $$ f(S) = \frac {w _1} {w(S) + w _1} $$ 发现 $f(S)$ 的值只与 $w(S)$ 有关，并且 $w(U) \le 10 ^5$，于是将 $f$ 的定义域改造为整数，重化一下式子，看第 $i$ 个权值对答案产生了多少贡献： $$ \sum _{i = 1} ^{w(U)} f(i) \sum _{1 \not \in S} (-1) ^{|S|} [w(S) = i] $$ 主要是求后面求和号的值。 发现暴力可以考虑背包，想起来实际上还有生成函数这么个东西。 那么每个猎人的生成函数应当是 $1 - x ^{w _i}$，故答案为： $$ \sum _{i = 1} ^{w(U)} f(i) \left ([x ^i] \prod _{j = 2} ^n (1 - x ^{w _j}) \right) $$ 可以直接分治 NTT（注意不是 CDQ 的，就是普通分治）$O(n \log ^2 n)$； 也可以类似付公主的背包一样 $O(n \log n)$ 地得到求 $\ln$ 后的式子再 $\exp$ 回去。 ~~当然建议用分治 NTT，考场上写个这个比写个整套板子快多了~~ 实际上分治 NTT 的复杂度为 $O(w(U) \log ^2 w(U))$，而 $\exp$ 的复杂度为 $O(w \log w)$，优秀很多。付公主的背包分治就会复杂度不对。 - 日常在多项式预处理时写了个 $n$ 而不是 $w(U)$……要注意这个东西。 # EGF $$ A(x) = \sum _{n \ge 0} a _n \frac {x ^n} {n!} \\\\ h _n = \sum _{i = 0} ^n {n \choose i} f _i g _{n - i} \Leftrightarrow H(x) = F(x) G(x) $$ 这是个奥妙重重的东西……一般用于有标号的计数中。 下面那个通常称为二项卷积。 注意这里积分和求导对应了移项，而乘 $x$ 对应了带系数的移项。 一些常用的表达形式： $$ e ^x = \sum _{n \ge 0} \frac {x ^n} {n!} \\\\ \frac{e ^x + e ^{-x}} 2 = \sum _{n \ge 0} \frac {x ^{2n}} {(2n)!} \\\\ \frac{e ^x - e ^{-x}} 2 = \sum _{n \ge 0} \frac {x ^{2n + 1}} {(2n + 1)!} $$ ## 无向连通图个数 有几种做法。首先设 $f _n$ 表示 $n$ 个点的无向连通图的个数，$g _n$ 表示无向图的个数，可以知道 $g _n = 2 ^{n(n - 1) / 2}$。 那么考虑枚举 $1$ 号点所在的连通块的大小，有转移式： $$ f _n = g _n - \sum _{i = 1} ^{n - 1} {n - 1 \choose i - 1} f _i g _{n - i} $$ 常规的分治 NTT 之类的就不提了，这里展示一下生成函数怎么做。 先把这个减号移到等式右边： $$ g _n = \sum _{i = 1} ^{n} {n - 1 \choose i - 1} f _i g _{n - i} $$ 注意这个能够成立的前提是定义了 $g _0 = 1$。 然后改变一下 $i$ 的枚举： $$ g _n = \sum _{i = 0} ^{n - 1} {n - 1 \choose i} f _{i + 1} g _{n - i - 1} $$ 发现这和二项卷积已经长得非常像了，但是 $f _{i + 1}$ 和这个 $n - 1$ 特别讨厌…… 这时需要联想到求导相当于左移，而积分相当于右移。那么上面的式子等价于： $$ G(x) = \int F'(x) G(x) $$ 把这个式子拆出来玩一下会发现和上面是符合的。 接下来就顺理成章： $$ G(x) = \int F'(x) G(x) \\\\ G'(x) = F'(x) G(x) \\\\ F'(x) = \frac {G'(x)} {G(x)} \\\\ \int F'(x) = \int \frac {G'(x)} {G(x)} \\\\ F(x) = \ln (G(x)) $$ 然后惊讶地发现求个 $\ln$ 就可以得到 $F(x)$ 了。 > 有些题也可以得到类似的式子，不过可能需要一些微分方程的基础知识才能解出来表达式；这个式子是最基础的。 上面算是比较严谨的推导，如果要真正考虑到其优美性质，会注意到：**无向图由无向连通图组合而成**。 那么相当于是 $$ G(x) = \sum _{m \ge 0} \frac {F^m(x)} {m!} $$ 相当于是枚举这个图由 $m$ 个连通块构成。然后你会惊奇地发现后面就是 $\exp (F(x))$ 的展开式，于是同样的得到了 $F(x) = \ln (G(x))$。 硬证明的话，把 $F ^m(x)$ 拆出来看看： $$ [x^n] F^m(x) = \sum _{S \text{ is a partition}} {n \choose s _1, s _2, \cdots, s _m} \prod _{i = 1} ^m f _{s _i} $$ ${n \choose s _1, s _2, \cdots, s _m}$ 是个多元组合数，等于 $\dfrac {n!} {s _1 ! s _2 ! \cdots s _m !}$。乘上这个东西相当于为每个连通图都分配了一个标号和位置。 但是无向图中，连通图的位置是没有关系的；所以最后要除掉一个 $m!$ 避免算重。 ## 射命丸文的笔记 > 求 $n$ 个点的竞赛图的期望哈密顿回路数量。 > > $n \le 10 ^5$ 首先哈密顿回路总数是好求的：对每条哈密顿回路分开考虑贡献， 发现是 $(n-1)! 2 ^{n(n - 1) / 2 - n}$。一条哈密顿回路肯定对应着一个环排列，环上的边固定方向后其他边可以任选方向。 于是问题变成了求强连通的竞赛图的数量。 需要知道一个结论：任意竞赛图缩点之后会得到一条链，链前面的节点向所有后面的节点均有连边，且方向固定。 所以一个竞赛图也可以看作强连通竞赛图的组合。但是由于是链，这时强连通竞赛图的位置是有意义的；所以 $$ \begin{aligned} G(x) &= \sum _{m \ge 0} F^m(x) \\\\ &= \frac 1 {1 - F(x)} \end{aligned} $$ 于是 $F(x) = 1 - \dfrac 1 {G(x)}$。多项式求逆即可。 用二项卷积的理论也是可以证明的。首先写出转移式：枚举拓扑序最小的强连通分量的大小，其他的点任意连边： $$ f _n = g _n - \sum _{i = 1} ^{n - 1} {n \choose i} f _i g _{n - i} $$ 将 $g _0$ 定义成 $1$，而 $f _0$ 定义成 $0$，移个项： $$ g _n = \sum _{i = 0} ^{n} {n \choose i} f _i g _{n - i} $$ 于是可以得到 $$ G(x) = F(x) G(x) + 1 $$ 加一个 $1$ 是因为 $f _0 = 0, g _0 = 1$，所以 $F(x)G(x)$ 的常数项会少一个 $1$。（要着重注意这个小问题） 所以 $$ F(x) = 1 - \frac 1 {G(x)} $$ 与前面所推的一致。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HEOI2016]求和]]></title>
    <url>%2Fblog%2FHEOI2016-%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[--- title: '[HEOI2016]求和' tags: [组合计数] categories: solution date: 2020-06-04 21:44:57 password: --- # Description 给出 $n$，求 $$ \sum _{i = 0} ^n \sum _{j = 0} ^i \begin{Bmatrix} i \\\\ j \end{Bmatrix} j! 2 ^j $$ 其中 $\begin{Bmatrix} i \\\\ j \end{Bmatrix}$ 表示第二类斯特林数，也即将 $i$ 划分成 $j$ 个非空集合的方案数。 $$ 1 \le n \le 10 ^5 \\\\ \texttt{Bonus:} n \le 10 ^7 $$ # Solution 首先我想吐槽一下，这真的不是随手化式子化到一半出出来的题吗…… $2$ 的次幂是友好的，主要是把这个斯特林数给处理掉。 关于第二类斯特林数，有一个为大家所熟知的公式： $$ i ^k = \sum _{j = 0} ^k \begin{Bmatrix} k \\\\ j \end{Bmatrix} j! {i \choose j} $$ 其组合意义相当于 $i$ 个盒子 $k$ 个球任放，左边显然，右边枚举有 $j$ 个盒子非空并将球分到这 $j$ 个盒子里去。 注意右边的上界可以改写成 $i$。考虑若 $k$ 为一定值，可以通过二项式反演得到： $$ \begin{Bmatrix} k \\\\ j \end{Bmatrix} j! = \sum _{i = 0} ^j (-1) ^{j - i} {j \choose i} i ^k $$ 把这个式子代入到题目所给的式子中（顺便修改 $j$ 的枚举上界为 $n$，斯特林数确保了改变上界不会出错）： $$ \sum _{i = 0} ^n \sum _{j = 0} ^n 2 ^j \sum _{k = 0} ^j (-1) ^{j - k} {j \choose k} k ^i $$ 看上去式子只是变的更复杂了……其实不然，注意到 $i$ 的枚举可以提到后面去： $$ \sum _{j = 0} ^n 2 ^j \sum _{k = 0} ^j (-1) ^{j - k} {j \choose k} \sum _{i = 0} ^n k ^i $$ 发现后面这个等比数列求和是非常友好的。令 $a _k = \sum \limits _{i = 0} ^n k ^i$，上式就变成了一个易于卷积的形式，可以做到 $O(n \log n)$。 实际上还能做到更好。再交换一下和式： $$ \begin{aligned} & \sum _{k = 0} ^n a _k \sum _{j = k} ^n 2 ^j (-1) ^{j - k} {j \choose k} \\\\ =& \sum _{k = 0} ^n a _k 2^k \sum _{j = k} ^n (-2) ^{j - k} {j \choose k} \end{aligned} $$ 看一下后面的那一块怎么算。 令 $$ b _j = \sum _{i = j} ^n {i \choose j} q ^{i - j} $$ 考虑如何在线性时间内求出 $b$。 $b _0$ 是易于计算的，而考虑 $b _j$： $$ \begin{aligned} b _j &= \sum _{i = j} ^n {i \choose j} q ^{i - j} \\\\ &= \sum _{i = j} ^n {i - 1 \choose j} q ^{i - j} + \sum _{i = j} ^n {i - 1 \choose j - 1} q ^{i - j} \end{aligned} $$ 两部分分开计算。 左部分： $$ \begin{aligned} & \sum _{i = j} ^n {i - 1 \choose j} q ^{i - j} \\\\ =& \sum _{i = j - 1} ^{n - 1} {i \choose j} q ^{i - j + 1} \\\\ =& q \sum _{i = j} ^{n - 1} {i \choose j} q ^{i - j} \\\\ =& q (a _j - {n \choose j} q ^{n - j}) \end{aligned} $$ 右部分： $$ \begin{aligned} & \sum _{i = j} ^n {i - 1 \choose j - 1} q ^{i - j} \\\\ =& \sum _{i = j - 1} ^{n - 1} {i \choose j - 1} q ^{i - j + 1} \\\\ =& \sum _{i = j - 1} ^{n - 1} {i \choose j - 1} q ^{i - (j - 1)} \\\\ =& b _{j - 1} - {n \choose j - 1} q ^{n - (j - 1)} \end{aligned} $$ 所以 $$ b _j = qb _j - {n \choose j} q ^{n - j + 1} + b _{j - 1} - {n \choose j - 1} q ^{n - j + 1} $$ 于是 $$ (1 - q) b _j = b _{j - 1} - q ^{n - j + 1} \left( {n \choose j} +{n \choose j - 1} \right) $$ 预处理好组合数和 $q$ 的幂次即可做到 $O(n)$ 的求出 $b$。 求出 $b$ 之后原式也易于在 $O(n)$ 内求出，故总复杂度 $O(n)$。注意求 $a _k$ 时需要线性筛。 # Code ```cpp #include #include #include #include #define Dec(x) (x >= mod ? x -= mod : 0) #define Inc(x) (x < 0 ? x += mod : 0) using namespace std; using LL = long long; const int maxN = 1e7 + 5; const int mod = 998244353; const int INV3 = 332748118; int n; int pw[maxN], inv[maxN], prop[maxN]; int fac[maxN], ifac[maxN]; int b[maxN]; int FPM(int bas, int ind) { int res = 1; while (ind) { if (ind & 1) res = (LL)res * bas % mod; bas = (LL)bas * bas % mod; ind >>= 1; } return res; } inline int C(int N, int M) { if (N < 0 or M < 0 or N < M) return 0; return (LL)fac[N] * ifac[M] % mod * ifac[N - M] % mod; } void Sieve() { static bool vis[maxN]; static vector prim; for (int i = 2; i n) break; vis[i * j] = true; prop[i * j] = (LL)prop[i] * prop[j] % mod; if (i % j == 0) break; } } } void Initmath() { fac[0] = ifac[0] = 1; for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1305G]Kuroni and Antihype]]></title>
    <url>%2Fblog%2FCF1305G-Kuroni-and-Antihype%2F</url>
    <content type="text"><![CDATA[--- title: '[CF1305G]Kuroni and Antihype' tags: [MST, 子集和 DP] categories: solution date: 2020-04-18 11:59:12 password: --- # Description $n$ 个点，每个点有点权 $a _i$，$i, j$ 之间有边当且仅当 $a _i \text{ AND } a _j = 0$。执行以下过程 $n$ 次： 1. 选择一个点 $u$ 染色。 2. 选择一个与 $u$ 相连的且已经染色的点 $v$，将 $a _v$ 计入答案。如果没有合法的 $v$，跳过该步。 输出最大的答案。 $$ 1 \le n \le 2 \times 10 ^5, 0 \le a _i \le 2 \times 10 ^5 $$ # Solution 设 $a _{n + 1} = 0$，并且默认 $n + 1$ 一开始已经被染色。 如果将每个点在 $2$ 过程中选择的点与它之间连一条边，会得到一棵树。如果将边权定义为 $a _i + a _j$，那么最终的答案即为边权之和减去点权之和，于是问题变为求解最大生成树。 ## $O(3 ^{18} \alpha (n))$ 由于只有两个点与起来为 $0$ 才会有边，所以加法相当于是或。 那么考虑枚举边权 $w$，再枚举 $w$ 的子集 $x$，将 $x$ 与 $w \text{ XOR } x$ 全部用并查集连起来即可。 ## $O(18 \times 2 ^{18} \log n)$ 考虑某个 B 开头求最大生成树的算法。初始时 $n + 1$ 个连通块，每次将每个连通块最大的出边找到然后并查集合并。可以证明不超过 $O(\log n)$ 次操作后图将连通。 如何找最大出边？因为子集有关的东西无法用数据结构方便的维护，也就是说不能到一个连通块之后将连通块里面的信息删除，特别麻烦。 一种特别巧妙的思路是用子集和 DP 求出 $S$ 的所有子集中点权的最大值，以及与这个最大值所在连通块不同的一个次大值。这样每个点的满足与其不在同一个连通块的最大出边只有可能在这两个中的一个。 每次利用子集和求出来的信息求出一个连通块的最大出边。 合并操作次数是 $O(n)$ 级别的所以并查集所带的 $\alpha (n)$ 不会计入总复杂度。 # Code ```cpp #include #include #define fir first #define sec second using namespace std; using LL = long long; using pii = pair; const int N = 1 < 18; const int maxN = 2e5 + 5; int n; LL ans; int a[maxN]; int fa[maxN], size[maxN]; pii large[maxN]; pii best[N + 5][2]; int Find(int x) { return x == fa[x] ? x : fa[x] = Find(fa[x]); } inline bool Merge(int u, int v) { int fu = Find(u), fv = Find(v); if (fu == fv) return false; if (size[fu] > size[fv]) swap(fu, fv); fa[fu] = fv, size[fv] += size[fu]; return true; } inline void Trans(pii A[2], pii B[2]) { for (int i = 0; i < 2; ++i) { pii t = B[i]; if (t.fir > A[0].fir or (t.fir == A[0].fir and t.sec != A[0].sec)) { if (A[0].sec != t.sec) A[1] = A[0]; A[0] = t; } else if (t.fir > A[1].fir and t.sec != A[0].sec) A[1] = t; } } int main() { ios::sync_with_stdio(false); cin >> n; for (int i = 1; i 1) { for (int i = 0; i < N; ++i) best[i][0] = best[i][1] = pii(-1, -1); for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>MST</tag>
        <tag>子集和 DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO 2020 US Open Solution]]></title>
    <url>%2Fblog%2FUSACO-2020-US-Open-Solution%2F</url>
    <content type="text"><![CDATA[--- title: USACO 2020 US Open Solution tags: [DP, 计数] categories: solution date: 2020-04-18 11:49:32 password: --- 双被吊打了.jpg # T1 Sprinklers 2: Return of the Alfalfa ## Description [link](https://loj.ac/problem/3283) ## Solution 观察题目性质可以发现，如果只看那些覆盖左下角的点，他们的并形成了一个递减轮廓线，并且覆盖右上角的那些点一定位于轮廓线的折处的右上角。 所以相当于是要 DP 出有多少个合法的轮廓线。 实际上还有一个问题，就是除了轮廓线上的点以外，其他的可以种洒水器的点都会有两种选择。这些点带来的方案数在 DP 中乘出来是不太现实的，转移方程会因此变得极其复杂，所以一个比较好的解决方案是把所有状态的值全部除掉一个 $2 ^{折点数量}$，最后再乘上 $2 ^{可以种洒水器的点的总数量}$ 即可。 设 $f(i, j)$ 表示已经考虑好了前 $j$ 列的轮廓线，第 $j$ 列的覆盖左下角的那个点在第 $i$ 行。（注意这里的 $i$ 可以到 $n + 1$） 转移时枚举 $k$ 表示 $[k, j]$ 这一块被当前轮廓线覆盖，可以得到转移方程： $$ f(i, j) = \frac {\sum _{k = 1} ^j \sum _{l = 1} ^{i - 1} [(i - 1, k) \text{ is coverable}] f(l, k - 1)} 4 $$ 因为这里增加了两个折点，所以除个 $4$。注意第一行和第 $n + 1$ 行考虑时只用除 $2$。 前缀优化一下就是 $O(n ^2)$ 的了。 ## Code ```cpp #include #include #define Dec(x) (x >= mod ? x -= mod : 0) using namespace std; typedef long long LL; const int maxN = 2e3 + 5; const int mod = 1e9 + 7; const int inv4 = 250000002; int n; char g[maxN][maxN]; int sum[maxN]; int f[maxN][maxN]; int FPM(int bas, int ind) { int res = 1; while (ind) { if (ind & 1) res = (LL)res * bas % mod; bas = (LL)bas * bas % mod; ind >>= 1; } return res; } int main() { ios::sync_with_stdio(false); cin >> n; int s = 0; for (int i = 1; i > (g[i] + 1); for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF708E]Student's Camp]]></title>
    <url>%2Fblog%2FCF708E-Student-s-Camp%2F</url>
    <content type="text"><![CDATA[--- title: '[CF708E]Student''s Camp' tags: [DP 优化, 概率] categories: solution date: 2020-01-19 16:28:22 password: --- # Description ![](/uploads/pic/2020-01-1908-44-15屏幕截图.png) $$ 1 \le n, m \le 1500, 1 \le k \le 10 ^5 $$ 答案对 $10 ^9 + 7$ 取模。 # Solution 首先容易知道最终每行剩下来的砖块一定是一个连续区间，并且问题相当于是问这 $n$ 行砖块中最终所有相邻行的区间交集非空的概率。 设 $p _i = {k \choose i} p ^i (1 - p) ^{k - i}$，表示 $k$ 天中摧毁掉左边/右边连续 $i$ 个方块的概率。易知一行最终剩下的区间为 $[l, r]$ 的概率为 $p _{l - 1} p _{m - r}$。 当然这对于每行均成立。于是考虑 DP，设 $f _{i, l, r}$ 表示前 $i$ 行均满足条件且第 $i$ 行的砖块区间为 $[l, r]$ 的概率。有转移： $$ f _{i, l, r} = p _{l - 1} p _{m - r} \sum _{[l', r'] \cap [l, r] \not = \varnothing} f _{i - 1, l', r'} $$ 初始时 $f _{0, 1, m} = 1$。 如果做前缀和优化并做转移已经可以做到 $O(n ^3)$。仍需更优秀的做法。 观察到这个转移可以转化成全集减去那些与其无交的区间。若记 $$ fr _i = \sum _{j = 1} ^i f _{j, i} \\\\ fl _i = \sum _{j = i} ^m f _{i, j} \\\\ Sr _i = \sum _{j = 1} ^i fr _j \\\\ Sl _i = \sum _{j = i} ^m fl _j $$ 这里默认把第一维滚掉了。 那么 $$ f _{l, r} = p _{l - 1} p _{m - r} (Sr _m - Sr _{l - 1} - Sl _{r + 1}) $$ 则 $$ fr _{i} = \sum _{j = 1} ^i p _{j - 1} p _{m - i} (Sr _m - Sr _{j - 1} - Sl _{i + 1}) \\\\ fl _{i} = \sum _{j = i} ^m p _{i - 1} p _{m - j} (Sr _m - Sr _{i - 1} - Sl _{j + 1}) $$ 预处理然后转移可以做到单次 $O(m)$ 的复杂度。总复杂度 $O(nm)$。 一开始没有把 $p$ 拆开，搞了一晚上……实际上如果能把 $p$ 拆出来直接拿着式子做应该还是比较好做。抽象成图形可能反而不太好做了。 Debug: 对 $fl$ 做后缀和时 `for` 打的是从 $1$ 到 $m$…… # Code ```cpp #include #include #define Dec(x) (x >= mod ? x -= mod : 0) #define Inc(x) (x < 0 ? x += mod : 0) using namespace std; typedef long long LL; const int maxN = 1505; const int maxK = 1e5 + 5; const int mod = 1e9 + 7; int n, m, k, p; int fac[maxK], ifac[maxK]; int P[maxN], sp[maxN], f[maxN], g[maxN], sf[maxN], sg[maxN], ft[maxN], gt[maxN]; int FPM(int bas, int ind) { int res = 1; while (ind) { if (ind & 1) res = (LL)res * bas % mod; bas = (LL)bas * bas % mod; ind >>= 1; } return res; } inline int C(int _n, int _m) { if (_n < 0 or _m < 0 or _n < _m) return 0; return (LL)fac[_n] * ifac[_m] % mod * ifac[_n - _m] % mod; } int main() { freopen("camp.in", "r", stdin); freopen("camp.out", "w", stdout); ios::sync_with_stdio(false); cin >> n >> m; int a, b; cin >> a >> b; p = (LL)a * FPM(b, mod - 2) % mod; cin >> k; if (k == 0) { cout < 1 < endl; return 0; } fac[0] = ifac[0] = 1; for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>DP 优化</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AGC021F]Trinity]]></title>
    <url>%2Fblog%2FAGC021F-Trinity%2F</url>
    <content type="text"><![CDATA[--- title: '[AGC021F]Trinity' tags: [DP, NTT] categories: solution date: 2020-01-17 13:32:28 password: --- # Description ![](/uploads/pic/2020-01-1522-02-15屏幕截图.png) $$ 1 \le n \le 8000, 1 \le m \le 300 $$ # Solution 首先可以知道对列的限制更紧，所以可以考虑围绕列来建立转移方程。 设 $f(i, j)$ 表示 $i$ 行 $j$ 列的矩阵，每行必染了一种颜色情况下，产生的 $A, B, C$ 的方案数。最终答案即 $\sum _{i = 0} ^n {n \choose i} f(i, m)$。 每次考虑新加一列会造成什么影响，也即将 $f(i, j)$ 转移到 $f(i + t, j + 1)$，其中 $t$ 表示出现在这一列的不属于前 $i$ 行的黑色格子数目。 （注意这里的加入是将这 $t$ 行插入到 $i$ 行里，而不是直接放到后面） 当 $t = 0$ 时，没有新加入行，所以相当于是第 $j + 1$ 列的格子可以任意染色，然后问不同的 $B _{j + 1}, C _{j + 1}$ 的方案数。当然是 $1 + i + {i \choose 2}$，分别是不染，左右端点重合和左右端点任选三种情况。（这里的左右端点分别指的是 $B, C$） 当 $t > 0$ 时，考虑建立两个虚行放在这加入的 $t$ 行的首尾端，再去将这 $t + 2$ 行分配到 $i + t + 2$ 行中去。那么在最终的分配结果中，首虚行的下一行代表着左端点，尾虚行的上一行代表着右端点。可以知道这样放出来的方案可以一一对应，故方案数为 ${i + t + 2 \choose t + 2}$。 于是可以写出转移式子。观察到是一个卷积的形式，NTT 优化即可。 $O(nm \log n)$。 # Code ```cpp #include #include #include #define Dec(x) (x >= mod ? x -= mod : 0) #define Inc(x) (x < 0 ? x += mod : 0) #define log2(x) (31 - __builtin_clz(x)) using namespace std; typedef long long LL; const int maxN = 8e3 + 5; const int maxM = 205; const int mod = 998244353; int n, m; int fac[maxN], ifac[maxN]; int f[maxN], g[maxN * 2], h[maxN]; int FPM(int bas, int ind) { int res = 1; while (ind) { if (ind & 1) res = (LL)res * bas % mod; bas = (LL)bas * bas % mod; ind >>= 1; } return res; } namespace NTT { const int maxN = 1 < (log2(::maxN) + 2) | 1; int omg[maxN], rev[maxN]; void NTT(int* arr, int lim, int fg) { for (int i = 1; i < lim; ++i) if (rev[i] < i) swap(arr[i], arr[rev[i]]); for (int t = 2; t]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP2019-S Solution]]></title>
    <url>%2Fblog%2FCSP2019-S-Solution%2F</url>
    <content type="text"><![CDATA[--- title: CSP2019-S Solution tags: [CSP] categories: solution date: 2019-12-18 08:15:52 password: --- 还是咕了一些题…… # Day1 ## T1 code 观察到格雷码顺次排列时，每一位均存在循环节，如第 0 位按照 `0110` 循环，第 1 位按照 `00111100` 循环，第 2 位则是 `0000111111110000`，于是按位对循环节长度取余后依次输出即可。 $O(n)$。 ## T2 brackets 一个基本的思路是对于一个右括号节点 $u$，找到与其匹配的左括号祖先 $v$，此时其对答案的贡献为当前这对括号加上 $v$ 上面与 $v$ 连续的括号匹配数量。 「连续」的要求是那些括号中间不能有空位。比如 `(()())()()`，若 $u$ 为最后一个，$v$ 为倒数第二个，那么连续括号匹配数量为 2（`(()())` 这个串左右两边的那对括号和 `()` 接在一起，且中间没有空位）。而如果变成 `(()())(()()` 就只有一个了，因为中间插入了一个左括号使得 `(()())` 和 `()` 不连续了。 或者用代码来描述：设 `match[u]` 表示与 $u$ 所匹配的左括号（当 $u$ 为右括号时值为 0），则对答案的贡献可以用 `cnt` 来表示。`cnt` 求法如下： ```cpp int cnt = 0; while (u != 0) ++cnt, u = fa[match[u]]; ``` 正确性应该很好证，因为对子串数目产生新的贡献只能这么产生。 于是对该树进行 DFS，用一个栈维护从根到该节点的左括号情况。若当前节点是左括号直接加入栈内，右括号则**取出**栈顶的左括号与其匹配成为一对括号并算上贡献。回溯时撤销这一步操作就行了。 当然没必要每次像上面的代码一样 $O(n ^2)$ 地跳，直接把 `cnt` 存为数组，每次新的答案就是 `cnt[fa[match[u]]] + 1`，`cnt` 更新为这个新的答案即可。 $O(n)$。核心代码： ```cpp void DFS(int u) { ans[u] = ans[fa[u]]; if (str[u] == '(') stk[++top] = u; else if (top) { match[u] = stk[top--]; cnt[u] = 1 + cnt[fa[match[u]]]; ans[u] += cnt[u]; } for (int i = head[u]; i; i = nxt[i]) DFS(to[i]); if (str[u] == '(') --top; else if (match[u]) stk[++top] = match[u]; } ``` # Day2 ## T1 meal 看错题差点死在这里……一开始看的题目是每个烹饪方式只能选一个食材，但是可以做多道菜…… 注意到题目所给的第三个条件比较恶心。对这个条件考虑补集转换，用任选方案数（注意，这里的任选还是得满足第 1,2 个条件）减去不满足第三个条件的方案数。 由于该条件的特殊性，不满足条件的食材只会出现一种。于是首先枚举是哪个食材不满足条件，也就等价于这个食材的菜数比其他所有食材的菜数和更大。 设这是第 $k$ 个食材。这样就很好做 DP 了：设 $f(i, j)$ 表示选完了前 $i$ 个烹饪方式的菜的情况下，当前第 $k$ 个食材的菜数比其他菜数的总和多 $j$ 道的方案数。这里的 $j$ 可以为负数。 那么当前烹饪方式有不选菜、选第 $k$ 个食材的菜、选其他食材的菜，有转移： $$ f(i, j) = f(i - 1, j) + f(i - 1, j - 1) * a _{i, k} + f(i - 1, j + 1) * (sum _i - a _{i, k}) $$ 其中 $sum _i$ 表示第 $i$ 个烹饪方式的菜的总和。 任选方案数为 $\prod \limits _{i = 1} ^n (sum _i + 1) - 1$。减 1 是因为不允许不选菜。 $O(n ^2 m)$。 ## T2 partition 首先有一个暴力 DP： 设 $f(i, j)$ 表示已经划分了前 $i$ 个数的段，最后一段以 $j$ 开头的最小总运行时间。设 $S(j, i) = \sum \limits _{k = j} ^i a _k$，有转移： $$ f(i, j) = \min _{0 < k < j, S(j, i) \ge S(k, j - 1)} \{f(j - 1, k)\} + S(j, i) ^2 $$ 直接按方程转移是 $O(n ^3)$ 的。注意到若将 $j$ 从 $i$ 到 $1$ 逆顺序转移，能够贡献的那些 $k$ 不断变多。于是设置一个指针 $p$，初值为 $i$，每次 $j \gets j - 1$ 时调整 $p$ 的位置不断向左走，即可做到均摊下 $O(1)$ 转移，复杂度 $O(n ^2)$。 状态数很明显的需要优化，打表可以发现：能够转移到其他状态的 $f(i, j)$ 必定满足 $f(i, j)$ 是最后一个合法的状态，即 $f(i, j + x)$ 均是不合法状态。换句话说，只要让以 $i$ 结尾的最后一段划出来的总和尽可能小，就可以构造出一种最优方案。 [myy 的证明](http://matthew99.blog.uoj.ac/blog/5299) 于是重设状态：设 $g _i$ 表示最大的满足以 $g _i$ 作为最后一段的开头能够合法的位置。有转移： $$ g _i = \max _{0 < j < i, S(j + 1, i) \ge S(g _j, j)} \{j\} + 1 $$ 设 $P _i = \sum \limits _{j = 1} ^i a _i$，将 $S(j + 1, i) \ge S(g _j, j)$ 变形为 $P _i \ge 2P _j - P _{g _j}$。再设 $T _i = 2P _i - P _{g _i}$。 用数据结构维护 $T$ 固然可行，但复杂度仍不够优秀。注意到其单调性：由于是取 $\max$ 并且是从前往后转移的，那么对于当前状态 $i$ 而言，前面的 $j$ 若有 $T _j \ge T _i$ 则 $j$ 一定不会比 $i$ 更优。 这是个典型的单调队列优化转移的情况。队尾出队按 $T$ 比较即可，当队头的后一个元素 $u$ 满足 $T _u < P _i$ 时可知队头已经不会再产生贡献，将队头出队。 注意一开始要放入 0，并设 $g _0 = 1$ 以减少边界情况的处理。 这样可以顺利获得 88pts。再考虑高精度的问题。 可以考虑将答案表示为 $a \times 10 ^{18} + b$ 的形式并进行运算。加法直接将 $a, b$ 分别相加（注意 $b > 10 ^{18}$ 时得进位）。乘法则是一个 `long long` 范围内数 $x$ 的平方，将 $x$ 表示为 $a \times 10 ^9 + b$ 的形式则有（将 $10 ^9$ 省略为 $B$）： $$ \begin{aligned} & x ^2 \\\\ =& (aB + b) ^2 \\\\ =& a ^2 B ^2 + 2abB + b ^2 \\\\ =& a ^2 B ^2 + 2(a'B + b')B + b ^2 \\\\ =& (a ^2 + 2a') B ^2 + (2b'B + b ^2) \\\\ =& (a ^2 + 2a') 10 ^{18} + (2b'B + b ^2) \end{aligned} $$ 其中 $ab = a' \times 10 ^9 + b'$。这样即可避免高精度问题。 同样的，$2b'B + b ^2$ 处注意进位。另外由于可以直接求出分段情况（也就是 $g _i$），不需要存答案数组，也避免了炸空间的问题。 ## T3 centriod 咕咕咕]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2Fblog%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[--- title: NOIP2018游记 tags: [游记] categories: diary date: 2019-12-04 16:06:16 password: --- 时隔一年再回来看这篇游记真是不忍直视……本着一个奇怪的原则，还是放上来算了。 如果没有靠数据湿度苟到这个一等恐怕早就退役了。 ![result](https://s1.ax1x.com/2018/11/27/FVAzXF.png) > 转眼间, 人生第一次NOIP就结束了. 成绩并不让人满意, 但是为了记录下自己的OI历程以及警醒以后的自己, 遂写下此文, 期望能够有所感悟和改进. # Day -31 初赛考完了之后过了两周, 信息组正式宣布停课. 早就迫不及待了. ~~因此也逃过了期中考试~~ 每天上午考试, 下午讲题, 晚上改题+自练, 循环往复, 周而复始. 但是我们考的比赛是`NOI Professional`... ~~完全超过了提高组的考点了好吗~~ 就这样, 习惯于被高二和本届dalao暴踩, `NOIP`也越来越近... # Day 0 上午搞了个联赛总动员, 大致意思就是鼓励大家调整心态 然后这一下午和晚上都放了假. 晚上就跑去看了一下`毒液`.(事实证明考前跑去看电影好像对心态平复不利...) `11:00`躺到床上, 一直心绪不宁, 到`12:30`才勉强睡着... 毕竟是第一次考联赛, 况且考不好就会变成最后一次emm 还是挺紧张的 # Day 1 `6:20`爬起来, 去食堂匆匆吃了个早饭, `7:10`左右车子就出发了. 到地方的时候才`7:40`左右, 考场还得等半个小时才开, 百无聊赖的站了半个小时. 看到4个国集dalao在旁边说话, 被他们的气场震得瑟瑟发抖 `8:10`放进考场, 调了会`vimrc`之后就发密码了. (当时根本不知道**飞雪连天**是什么意思...) 首先看了一下T1, $O(nlogn)$ 线段树解法??? 大致看一下没什么特别好的思路, 把T2和T3都看了一遍 大凯的疑惑??? 二分答案+树形DP??? 除了T3部分分之外感觉都十分不可做, 又滚回来肝T1 想了半个小时没个结果, 只想出个70分的暴力...打完就走了 又去肝T2, 因心态已经有点爆炸(T1都打不全, T2T3没一点思路), 心里特别乱, 连大样例都没有手推, 凭空往数论方面想了好久...自然是什么都打不出来(当时我还认为T2是个`省选/NOI-`) 到放弃T2再看T3, 心态已经完全炸了. 思路杂乱自然什么都做不了, 又想着想正解又想着部分分怎么拿, 于是T3正解也没想出来, $a_i=1$ 的部分分也没有拿, 匆匆拿了个40就走了. 滚回去看T2, 这时候已经`10:20`了... 当时是有点绝望了 看了一眼T2的大样例, 我突然有个大胆的猜想: **b绝对是a的子集**? 又想了五分钟, 想到了筛法 手推了三组样例, 发现是对的时候, 心态有所恢复- - 打了个复杂度极高的筛法, 一发过了大样例. 于是期望得分+=80. 这时候11:00了都... 然后在T1和T3之间一直徘徊...两题都没思路 后来就调自己T3的部分分, 确保有40之后就放弃了. 于是D1期望得分`70+80+40=190`. 当时因为在绝境中打出了T2的80分, 所以出考场的时候心态还算平静 出去一交流: > 我: 你们今天打的怎么样? > > zqr: T1 100, T2 80, T3 40, 大概220吧. > > 我: WA TQL! T1你怎么打出来的? > > zqr: 套个线段树乱搞, 过了 $10^5$ 的大样例233 > > wzr: 啊? T1不是2013的原题吗? 在洛咕上好像是`普及-`吧 还有T3不是能骗55分吗? $a_i=1$ 挺好写的啊 > > 我&zqr:....... 于是乎 心态再次爆炸 下午回去自测, 洛咕数据比较水, T1有80, T2直接满了(后来洛谷加了个最毒瘤的重测卡成了95), T3如预期拿到了40 还好没有挂分, 只能祝自己Day2 rp++了... 和我爸出去吃了个饭, 随便晃晃, 回机房的时候都`20:30`了 我们机房(都是新学4个月的人)有个`AK`的神仙 orz 没再复习了 注重于调整心态(实际上没什么用) 晚上依然睡不着觉 `0:00`勉强睡着 # Day 2 和昨天上午一样, 准时出发, `7:45`到了. 又等了好久才放进考场. 进去重配了`vimrc`, 然后 **笑书神侠**?? 啥玩意?? 并不理解其中意义, 抓紧时间看题面 果然如他们所言, D2难度上了个档次 T1看完题面, ??? 这是能做的??? 看到 $m=n-1\ or\ m=n$ 才放心- - 在看一眼T2 题意都看的不是很明白...果断放弃 T3 特别迷... 又是个树形DP吗... 哪有DP这样子带修改的... (出考场才反应出来是`动态DP`) 这怕是我们考的`NOI Professional`的难度 转回T1, 10min打完了60, 心态良好 然后开始搞基环树的40分 这中间折腾了一个小时, 想出一个时间复杂度非常优秀的做法 $O(nlogn)$ 后来我的分数告诉我 我看错题意了 我没怎么深刻理解题意 直接当做一条边可以走两次 实际上有个非常重要的东西 > ..., 走向一个**没有去过**的城市, ... 当时打上去调了半小时过了大样例, 试了组极限数据保证不`TLE`之后就欢天喜地的扔掉了T1 继续看T2 觉得十分不可做 部分分都没看就看T3去了 然后依然没有任何头绪... 做过原题都想不起来... 浪费一个小时毫无建树... 心态爆炸.jpg 之后连 $O(n!)$ 的暴力 $20pts$ 都不想打了 直接扔掉了这道题 `11:20`左右才又开始看T2... 看到 $n \le 2$ 的部分分的时候已经`11:40`了 只把 $n,m \le 3$ 的数据打了(实际上只打了一部分 $n=2,m=3\ or\ n=3,m=2$ 这部分没时间推了...) 出考场的时候心态已经完全崩了 预计得分`100+15+0=115` 因为我没有在T2上花什么时间 想不出来很正常 所以我**最怕**出考场的时候出现这种对话: > 我: 打的怎么样? > > zqr: `60+100+44=204`吧 当时脑子里觉得可能会出现这种情况 心态已经完全爆炸了 交流了下发现没有... T2都不会写 暂且松了口气 回去自测才发现T1挂了...挂掉30 T2 15分, T3 0分 预估的最低得分是`70+80+40+72+10+0=272` 完全绝望 大致和同学聊了一会 我已经快垫底了 `GC`神仙`400+`了已经...同是新人为什么我这么菜呢... 事已至此, 再怎么做都无法挽回了 于是晚上思考人生+平复心态 改题都不怎么想改... dalao聊成绩的时候被各种暴踩 就当给自己锻炼心态了- - ~~以前打了那么久的`LOL`练的心态可不是白练的~~ 只能祈求`NOIP`的数据水一点了 # Day 4 上午上文化, 中午依然来机房过快乐日子 这才听到他们说我们本校的毒瘤数据出了 每个人测了一遍 `GC`神仙430 orz 大着胆子看了一眼自己的成绩 `90+100+55+84+15+0=344` ??????????????????????????????????????????????????????????????????? 这真的是毒瘤数据???? 但别人好像分数都挺正常的...唯独我的拉上去了70分 虽然知道`344`是不可能的, 但是好歹还是让我心态略微平复了一点 ~~笑容渐渐恢复~~ # Day 6 学军的数据来了. 果然很毒瘤, 我一落千丈: `70+80+40+68+15+0=273` 跟最低预估分差不多了. 不过还好吧, 毕竟现在我的分数范围变成了`273-344`了- - 希望`NOIP`给个救命分吧2333 中午顺便改了改简单的题 D1T1T2, D2T1都改了 # Day 10 听说今天早上成绩会出. `10:00`大课间匆匆跑过来 > 成绩单未上传, 请稍后查看! 还是等明天吧... # Day 11 早上`7:00`, 我爸就打电话过来说出了. 我发了账号密码过去叫他帮我查. `7:30`左右他回了电话过来 ~~当时我还在食堂为作业写不完发愁~~ `319`. `NOIP`还是挺给面子的. 后来查到如文章开头所示的各题得分, 让我惊讶的一点是D1T2`NOIP`的数据20分都放过去了, 挺良心的- - 还有D2T1错解得了个`84`, 正常得分应该是`72`的233 # 尾声 仔细想想, 还是自己基础不够扎实, 也有一些心态上的问题, 导致了联赛考的如此之差. 就比如D1T2, 要不是`lzh`dalao说"这题比[砝码称重](https://www.luogu.org/problemnew/show/P1441)不知道简单到哪里去了", 我都根本想不起来我做过砝码称重这道题. 要是当时能想起来, D1T2应该是可以10min切掉的. T1就不说了... 自己过分自大看不起`普及-`, 但就是这题我想不出来. (数据范围放了 $O(n\text{log}n)$ 过去, 但我也没打) T3的话, 如果能在1h内搞完T1和T2, 用两个半小时我应该还是能想出来的 D2的话 T1错在没认真读题 (小插曲: 当时我改题的时候下了一波洛咕的数据, 看完输入输出后还以为洛咕数据是错的- -打算投诉的时候`csy`dalao闻讯赶来, 嘲讽了我一波, 我那时候才知道理解错了) T2的话就随缘了... $n \le 2$ 时间给多应该可以推出来 T3就不说了 那`44`分的教训可以让我铭记一生 恬不知耻的算了一下最高得分: `100+100+55+100+65+44=464`, 这也就是现阶段的我状态**最好最好最好**下能拿到的分数了(然而 $tan\ \frac{k\pi}{2},k \in Z$) 强行苟在组里没有退役, 这次的教训已经够惨重了, 加油吧. 也有一些朋友退役了... 衷心的祝愿文化课快乐. # Update in `12.4` `HN`的分数线是`305`. 虽然我知道今年分数线放了很多水, 省一并不值钱, 但是听到消息的时候还是很高兴的. 为`csy`的`302`默哀... 接下来的一年, 尽管莽吧 # Thanks for your reading.]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相关]]></title>
    <url>%2Fblog%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[--- title: 多项式相关 tags: [多项式] categories: summary date: 2019-12-04 15:58:25 password: --- 边学边写的，不能完全保证正确性……请带着批判的眼光阅读 # FFT & NTT ## 求点值表达 假设 $A(x)$ 长度为 $2n$，系数向量为 $(a _{0 \cdots 2n - 1})$，且已经求出 $A _1(x)$ 和 $A _2(x)$ 的点值表达 $\{A _1(\omega _n ^0), A _1(\omega _n ^1), \cdots, A _1(\omega _n ^{n - 1})\}$ 及 $\{A _2(\omega _n ^0), A _2(\omega _n ^1), \cdots, A _2(\omega _n ^{n - 1})\}$，其中 $$ A _1(x) = a _0 + a _2 x + a _4 x ^2 + \cdots + a _{2n - 2} x ^{2n - 2} \\\\ A _2(x) = a _1 + a _3 x + a _5 x ^2 + \cdots + a _{2n - 1} x ^{2n - 1} \\\\ $$ 那么有 $$ A(x) = A _1 (x ^2) + xA _2 (x ^2) $$ 从而 $$ \begin{aligned} & \forall k \in [0, n), \\\\ A(\omega _{2n} ^k) &= A _1 (\omega _{2n} ^{2k}) + \omega _{2n} ^k A _2 (\omega _{2n} ^{2k}) \\\\ &= A _1 (\omega _n ^k) + \omega _{2n} ^k A _2 (\omega _n ^k) \\\\ A(\omega _{2n} ^{k + n}) &= A _1 (\omega _{2n} ^{2k + 2n}) + \omega _{2n} ^{k + n} A _2 (\omega _{2n} ^{2k + 2n}) \\\\ &= A _1 (\omega _n ^k) - \omega _{2n} ^k A _2 (\omega _n ^k) \\\\ \end{aligned} $$ # 全家桶 > 以下有可能将多项式 $A(x)$ 简写为 $A$。 ## $\ln$ 给定 $H(x)$，求多项式 $A(x) \equiv \ln H(x) \pmod {x ^n}$。 对两边求导再积分： $$ A(x) \equiv \ln H(x) \pmod {x ^n} \\\\ A'(x) \equiv \frac {H'(x)} {H(x)} \pmod {x ^n} \\\\ A(x) \equiv \int \frac {H'(x)} {H(x)} \pmod {x ^n} $$ 于是只需要求逆、求导、乘法和积分即可。 注意保证了 $H(x)$ 的常数项为 1，以此确定不定积分时的 $C = 0$。 ## 牛顿迭代 求一个 $A(x)$ 满足函数 $f(A) \equiv 0 \pmod {x ^n}$。相当于是求 $f$ 的零点。 假设已经求出 $f(A) \equiv 0 \pmod {x ^n}$ 的解 $A(x)$，现在要求 $\pmod {x ^{2n}}$ 意义下的解 $B(x)$。 考虑 $B(x)$ 在 $A(x)$ 处的泰勒展开式： $$ f(B) \equiv \sum _{i = 0} ^{+\infty} \frac {f ^{(i)} (A)} {i!} (B(x) - A(x)) ^i \pmod {x ^{2n}} $$ 注意 $f ^{(i)} (A) \not = (f(A)) ^{(i)}$。 由于 $B(x), A(x)$ 前 $n$ 项系数一样，故当 $i \ge 2$ 时，$(B(x) - A(x)) ^i$ 在 $\pmod {x ^{2n}}$ 的意义下全部变为 0。 故 $$ f(B) \equiv f(A) + f'(A) (B(x) - A(x)) \equiv 0 \pmod {x ^{2n}} $$ 得到 $$ B(x) \equiv A(x) - \frac {f(A)} {f'(A)} \pmod {x ^{2n}} $$ 于是就有一种船新的方法解释一些操作了。 ### 求逆 设给定多项式为 $H(x)$，相当于是求函数 $f(A) = \frac 1 A - H$ 在 $\pmod {x ^n}$ 意义下的零点。 应用牛顿迭代法得到 $$ B \equiv A - \frac {\frac 1 A - H} {- A ^{-2}} \pmod {x ^{2n}} $$ 也即 $B \equiv 2A - A ^2 H \pmod {x ^{2n}}$。与常见求逆式子一致。 另外式子拆成 $A(2 - AH)$，再对 $A, H$ 分别 NTT 变为点值表达后统一乘起来再转回去，比乘三次常数小很多。 ```cpp NTT(_H, lim, 1), NTT(B, lim, 1); for (int i = 0; i < lim; ++i) A[i] = (LL)B[i] * (mod + 2 - (LL)B[i] * _H[i] % mod) % mod; NTT(A, lim, -1); ``` ### 开根 设给定多项式为 $H(x)$，相当于是求函数 $f(A) = A ^2 - H$ 在 $\pmod {x ^n}$ 意义下的零点。 应用牛顿迭代法得到 $$ B \equiv A - \frac {A ^2 - H} {2A} \pmod {x ^{2n}} $$ 也即 $B \equiv \frac {A ^2 + H} {2A} \pmod {x ^{2n}}$。 ### $\exp$ 设给定多项式为 $H(x)$，相当于是求函数 $f(A) = \ln A - H$ 在 $\pmod {x ^n}$ 意义下的零点。 应用牛顿迭代法得到 $$ B \equiv A - \frac {\ln A - H} {\frac 1 A} \pmod {x ^{2n}} $$ 也即 $B \equiv A (1 - \ln A + H) \pmod {x ^{2n}}$。 至于对 $\ln$ 泰勒展开产生的收敛性问题我不太清楚……不过学生成函数那块的时候一堆收敛问题都没搞懂2333 ## 快速幂 求 $A$ 满足 $A \equiv H ^k \pmod {x ^n}$。$k \le 10 ^{10 ^5}$。 取 $\ln$ 再 $\exp$ 回去可以得到 $A \equiv \exp(k \ln H) \pmod {x ^n}$。 取 $\ln$ 时有个常数项问题需要考虑，一般题目里保证 $H$ 的常数项为 $1$。不是 $1$ 的话除掉再取 $\ln$ 就行。是 $0$ 还需讨论，略。 ## Code 这板子跑的还是蛮快的…… ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-12-02 19:46 * FileName : wib.cpp * Website : https://endsah.tk * *******************************************************/ #include #include #include #include typedef long long LL; #define log2(x) (31 - __builtin_clz(x)) #define Dec(x) (x >= mod ? x -= mod : 0) #define Inc(x) (x < 0 ? x += mod : 0) #define debug(...) fprintf(stderr, __VA_ARGS__) #define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s) #define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++) #define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch)) #define __bufsize (1 < 21 | 1) char _ibuf[__bufsize], _obuf[__bufsize], _stk[50]; char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk; struct END { ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } } __________; inline int read() { register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = x * 10 + (ch & 15), isdigit(ch = getchar())); return x; } inline int read_mod(const int& mod) { register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x * 10ll + (ch & 15)) % mod, isdigit(ch = getchar())); return x; } template]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP2019游记]]></title>
    <url>%2Fblog%2FCSP2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[--- title: CSP2019游记 tags: [游记] categories: diary date: 2019-12-04 15:58:17 password: --- 看了一眼去年的游记，感觉自己还是太 naive 了…… 两年的 Day2T1 都看错题了可还行。 # Day0 今年貌似没有联赛动员会……晚上睡的还算早，不像去年在床上躺了一个小时。 # Day1 进考场先配了会 vimrc。 T1, 2, 3 都先看了一眼。全部不会。有点慌了。 再回头看一眼 T2，发现有个比较好写的 $O(n)$ 做法。写了 20mins 过了大样例。不过大样例好像很特殊，于是写了 $O(n ^3)$ 的暴力拍，没什么问题。（顺带一提湖大的机子是真的好，拍的贼快） 再对 T1 打了会表，发现每一位有循环节。注意了一下 `unsigned long long` 和 `1ull < 64` 的问题大概过了。也写了拍，没拍出来错。 这个时候大概过去 1h 不到。然后对着 T3 自闭了，还妄想着能搞正解，最后链和菊花都没搞出来，`2h30mins = 10pts` 太真实了。出考场的时候想着今天可能人均 260 了，但好像并没有……稍微安了点心。 另外 T2 那些主席树线段树合并做法都是什么……感觉我啥都不会啊…… # Day2 T1, 2, 3 都先看了一眼。全部不会。 想着尽量快过掉 T1 去拿 T2, 3 的高部分分算了。然后认真想 T1。 想到 9:30 还没思路，于是写了个 T2 64pts 缓缓。 想到 10:10 还是**连 T1 暴力都不会**，于是写了 T3 40pts 缓缓。 10:40 实在慌了，去上了个厕所。事实证明这实在太有用了，回来发现我tmd看错题了。我看的题意是每种烹饪方式只能选一个食材，但是可以做多道菜…… 看对题又想了一会，发现直接拿草稿纸上我 9:15 写的原本想当暴力用的 DP 思路就可以 $O(n ^2 m)$……于是开始码，11:40 才过完样例。 我想着剩下这点时间应该可以搞出 T3 链的分，然后就开始 rush。论 11:58 还在调试是一种怎样的体验…… 不过因此 T3 的完美二叉树的分没有任何时间搞了，凭空掉了 20pts。 幸好临死前把题面又看了一遍，要不然人给翻没了……不过就算强行自救了一波 T2, 3 的部分分比别人还是少拿了很多。 可能是人生中最刺激的一场考试了。 # Day3 自测貌似没挂分，`100 + 100 + 10 + 100 + 64 + 55 = 429`。 去洛咕随便挑了几篇游记看都是 450+ 的…… # Day? 官方成绩和自测一样。]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1090J]Two Prefixes]]></title>
    <url>%2Fblog%2FCF1090J-Two-Prefixes%2F</url>
    <content type="text"><![CDATA[--- title: '[CF1090J]Two Prefixes' tags: [KMP 自动机, fail 树] categories: solution date: 2019-10-20 20:47:19 password: --- # Description 给定字符串 $S, T$，求 $S$ 的非空前缀拼上 $T$ 的非空前缀形成的本质不同的字符串数。 $$ 1 \le |S|, |T| \le 10 ^5 $$ # Solution 后缀自动机做法还不会，略。 **对文本串 $T$ 建出 KMP 自动机，匹配串 $S$ 在上面跑所到的最终节点 $u$ 满足 $u$ 所代表的 $T$ 的前缀是最长的，能匹配 $S$ 的某个后缀的前缀节点**。 考虑简单容斥，总字符串数为 $|S| \times |T|$，减去重复字符串数。 假设 $a, a'(|a| < |a'|)$ 和 $b, b'$ 分别为 $S, T$ 的某个前缀，并且 $a + b = a' + b'$。 那么 $b'$ 一定为 $b$ 的某个 border（换言之，$b'$ 既是 $b$ 的前缀，也是 $b$ 的后缀）。 ![](/uploads/pic/gp.png) 紫色和蓝色部分分别相同。 可以得到 $a'$ 的去掉 $a$ 的那段后缀和 $b$ 去掉 $b'$ 的部分（也就是紫色部分）完全一样。因为后缀的前缀相当于子串，所以枚举所有的 $b$，令 $b'$ 为 $b$ **最长**的 border，用 $b' - b$ 得到 $T$ 的一段前缀，这段前缀在 $S$ 中作为子串出现的次数就是重复次数。 为何不是所有 border 而是最长的 border，是因为要避免重复减去。 ![](/uploads/pic/gp2.png) 黄色部分为 $T _j$ 的最长的 border，蓝线部分相同。由上面的内容，$S _i + T _{j} = S _{BLUE} + T _{YELLOW}$。此时视作删去 $S _i + T _j$，而非删去 $S _{BLUE} + T _{YELLOW}$。 如果计算所有的 border，$S _i + T _j$ 这个不合法的贡献就有可能会被删去多于一次。因为对于任意的 $S _i + T _j$ 都是删除不少于一次，所以一定不合法。取最长的 border 是为了保证能删除所有的不合法的情况。 现在还需要解决找到 $T$ 的某一个前缀在 $S$ 中出现了几次的问题。将 $T$ 的 KMP 自动机建出来，用 $S$ 的字符逐个匹配，可以得到 $S$ 的所有后缀与 $T$ 能匹配的最长公共前缀。 设 $u$ 是 $S$ 的某个后缀匹配到的最长公共前缀的前缀节点，那么需要在 fail 树上将 $u$ 到根的路径全部 +1，因为 $u$ 仅代表最长而不是所有，需要将是它的 border 的前缀都 +1。 这是个简单的树上差分问题，统计完后直接做就行。 $O(n)$。代码里面记得注意一些细节，因为不能够接空串。也不需要显式的建出 KMP 自动机并补转移边，直接暴力跳 fail 就行了，复杂度是对的。 # Code ```cpp #include #include #include using namespace std; typedef long long LL; const int maxN = 1e5 + 5; int n, m; LL ans; int fail[maxN], cnt[maxN]; char S[maxN], T[maxN]; int main() { freopen("password.in", "r", stdin); freopen("password.out", "w", stdout); ios::sync_with_stdio(false); cin >> (S + 1) >> (T + 1); n = strlen(S + 1), m = strlen(T + 1); for (int i = 2, j = 0; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>KMP 自动机</tag>
        <tag>fail 树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「计算客国庆赛」简单数据结构题]]></title>
    <url>%2Fblog%2F%E3%80%8C%E8%AE%A1%E7%AE%97%E5%AE%A2%E5%9B%BD%E5%BA%86%E8%B5%9B%E3%80%8D%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[--- title: 「计算客国庆赛」简单数据结构题 tags: [根号分治, 二维数点] categories: solution date: 2019-10-15 22:25:05 password: --- # Description [Link](https://nanti.jisuanke.com/t/41794) 有 $n$ 个魔法物品（编号为 $1, 2, \cdots, n$）和 $m$ 对互斥关系，每对关系形如 $x, y$，表示编号为 $x$ 和 $y$ 的魔法物品会相互排斥。 回答 $q$ 次询问，每次询问给出 $k$ 个区间 $[l_1,r_1], [l_2,r_2],\cdots,[l_k,r_k]$，你需要知道这 $k$ 个区间的并是否包含互斥的魔法物品。 $$ 1 \le n, q, \sum k \le 10 ^5 $$ 保证询问区间之间互不相交，且左端点递增。部分测试点强制在线。 # Solution 实际上部分分给出了一定的提示。考虑两类暴力： 1. 遍历 $k$ 个区间全部打上标记，再枚举 $m$ 对关系进行 check。单次询问时间复杂度 $O(n + m)$。 2. **将限制关系放至二维平面**，假设限制关系为 $(a, b)$，则向二维平面插入一个坐标为 $(a, b)$ 的点。 每次枚举两个区间 $[l _1, r _1], [l _2, r _2] (r _1 < l _2)$，若以 $(l1, l2)$ 为左下角点，$(r1, r2)$ 为右上角的矩形内部有点，则表明包含互斥物品。时间复杂度 $O(k ^2 \log n)$（主席树二维数点） 则考虑根号分治。设阈值 $U$，若 $k > U$ 使用第一种暴力，否则使用第二种。两种操作操作次数均不超过 $\frac q U$，故总复杂度为 $O(q (\frac {n + m} U + U \log n))$，易知 $U$ 取 $\sqrt {\frac n {\log n}}$ 得到最优复杂度 $O(n \sqrt {n \log n})$（几个变量复杂度同阶，故省略）。 常数巨小不开 O2 也能过。 还有一个理论复杂度是 $O(n \sqrt n)$ 的做法。题解里面讲的分块看不懂，这里的 $\sqrt n$ 是 K-D Tree 操作矩形的复杂度。 还是将限制关系放在二维平面上考虑，一开始所有点的点权均为 0。 遍历 $k$ 个区间，设当前区间为 $[l, r]$，首先将横坐标在 $[l, r]$ 内的所有点整体加上 1，然后查询纵坐标在 $[l, r]$ 内的点是否有点权大于 1 的点。有则表明包含了互斥物品。 矩形加，矩形查（而且是对矩形内部的某些关键点操作），K-D Tree 是很好的选择。然而实测完全不像个 $\sqrt n$ 的东西，50000 的数据节点访问次数就到了 $10 ^7$ 级别，更别说一大串常数了... 另外这个做法可以预先加好再查询，易知这不会造成影响。如果有用这个思路过了的，求能教一教... # Code ## gen ```python from random import randint import os N = int(100000) cnt = 0 while True : T = 5 outs = "%d 0\n" % T for o in range(T) : n, m, q = N, N, N sumk = N outs += "%d %d %d\n" % (n, m, q) for i in range(m) : x, y = randint(1, n), randint(1, n) while x == y : y = randint(1, n) outs += "%d %d\n" % (x, y) for i in range(q) : lis = set() last = 0 while len(lis) < sumk and last != n: l, r = randint(last + 1, n), randint(last + 1, n) if l > r : l, r = r, l lis.add((l, r)) last = r a = sorted(list(lis)) outs += "%d " % len(a) sumk -= len(a) for j in a : outs += "%d %d " % j outs += '\n' print(outs, file = open("c.in", "w")) exit() os.system("./std && ./c") if os.system("diff c.out c.ans") : print("WA") exit() else : cnt += 1 print("AC %d times!" % cnt) ``` ## std ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-10-12 14:19 * FileName : wib.cpp * Website : https://endsah.cf * *******************************************************/ #include #include #include #include #include typedef std::pair pii; #define fir first #define sec second #define debug(...) fprintf(stderr, __VA_ARGS__) #define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s) #define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++) #define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch)) #define __bufsize (1 < 21 | 1) char _ibuf[__bufsize], _obuf[__bufsize], _stk[50]; char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk; struct END { ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } } __________; inline int read() { register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = x * 10 + (ch & 15), isdigit(ch = getchar())); return x; } template > 1; if (pos r or qr < l) return 0; if (ql 1; return _query(l, mid, ls[cur]) + _query(mid + 1, r, rs[cur]); } int Query(int t, int l, int r) { ql = l, qr = r; return _query(1, n, root[t]); } void Print() { printf("%d\n", ncnt); for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>根号分治</tag>
        <tag>二维数点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ARC093E]Bichrome Spanning Tree]]></title>
    <url>%2Fblog%2FARC093E-Bichrome-Spanning-Tree%2F</url>
    <content type="text"><![CDATA[--- title: '[ARC093E]Bichrome Spanning Tree' tags: [MST, 计数] categories: solution date: 2019-10-09 09:55:52 password: --- # Description 给定一个 $n$ 点 $m$ 边的无向连通图，现需要对每条边染黑或白色。 定义一棵生成树合法，当且仅当其至少有一条黑边和白边。 问有多少种染色方案满足最终图中合法的最小生成树的权值等于 $x$。 $$ 1 \le n \le 1000, 1 \le m \le 2000, 1 \le x \le 10 ^{12} \\\\ \texttt{Bonus:} 1 \le n \le 5 \times 10 ^5, 1 \le m \le 10 ^6 $$ 2019-10-8 # Solution 设 $f(lim)$ 表示最终图中合法最小生成树的权值**大于等于** $lim$ 的方案。答案可表示为 $f(X) - f(X + 1)$。 现在考虑怎么求出 $f(lim)$。 首先建出最小生成树，若其权值 $sum$ 大于等于 $lim$，则 $2 ^m - 2$ 种染色方案均合法（除了全部同色的情况之外）。 否则，易知最小生成树的边必然**全部同色**。此时再考虑破圈算法，即枚举一条非树边 $(u, v, w)$，在最小生成树上找到 $u, v$ 路径上的最大边权 $p$，如果 $sum - p + w$ 仍小于 $lim$，则说明这条边也应当与最小生成树上的边同色，否则就可以得到一个合法的权值小于 $lim$ 的生成树。 有一个这样的问题：有没有可能存在两棵权值相同的最小生成树 $A, B$，使得某条非树边在 $A$ 中可以破圈得到小于 $lim$ 的生成树，而在 $B$ 中无法得到？ 结合「最小生成树一定是最小瓶颈生成树」的结论可以得到这是不可能的。 假设最终得到有 $cnt$ 条边必须同色，那么最终方案数即 $2 ^{m - cnt + 1} - 2$。 树上路径最大值可以直接倍增求解，时空复杂度 $O(n \log n)$。 # Code ## gen ```python from random import randint from cyaron import * import os cnt = 0 while True : T = 5 outs = "%d\n" % T for o in range(T) : n = 10 m = randint(n, n * (n - 1) // 2) X = randint(1, 100) outs += "%d %d %d\n" % (n, m, X) graph = Graph.UDAG(n, m, self_loop = False, repeated_edges = False, weight_limit = (1, 15)) outs += graph.to_str() + '\n' print(outs, file = open("zhuzhu.in", "w")) os.system("./std && ./zhuzhu") if os.system("diff zhuzhu.out zhuzhu.ans") : print("WA") exit() else : cnt += 1 if cnt % 100 == 0 : print("AC %d times!" % cnt) ``` ## std ```cpp #include #include #include #include #include using namespace std; typedef long long LL; const int maxN = 1e5 + 5; const int maxM = 2e5 + 5; const int mod = 1e9 + 7; int n, m, T, ecnt; int head[maxN], dep[maxN]; int to[maxM], nxt[maxM], wht[maxM]; int f[20][maxN], MAX[20][maxN]; LL X, mstsum; bitset ismst, vis; struct Edge { int u, v, w; Edge() { } Edge(int _u, int _v, int _w) : u(_u), v(_v), w(_w) { } } edge[maxM]; bool operator> m >> X; for (int i = 1; i > o.u >> o.v >> o.w; } sort(edge + 1, edge + m + 1); U::Init(), Init(); for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>MST</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF487E]tourists]]></title>
    <url>%2Fblog%2FCF487E-tourists%2F</url>
    <content type="text"><![CDATA[--- title: '[CF487E]tourists' tags: [双连通分量, 圆方树] categories: solution date: 2019-10-06 16:38:40 password: --- # Description 给定一个 $n$ 点 $m$ 边的连通无向图，点有点权，无自环，无重边。$q$ 次操作： 1. 修改一个点的点权。 2. 询问从 $a$ 到 $b$ 的所有**简单路径**（不能经过重复的点）中，路径所经过点最小值最小的路径，输出这个最小值。 $$ 1 \le n, m, q \le 10 ^5 $$ # Solution 一道比较板子的题，大概说一下思路。 根据题目要求可以知道这题应该是要根据点双来做的。路径经过一个点双时，易知这个点双内的最小值一定能被走到。 不会缩点双，所以拿了个圆方树来搞。 然而网上找点双的代码多式多样，比如 [hk-cnyali](https://hk-cnyali.com/2019/03/13/%E3%80%8CAlgorithm%E3%80%8D%E5%85%B3%E4%BA%8Etarjan-%E7%82%B9%E5%8F%8C-%E8%BE%B9%E5%8F%8C/) 的，对 `low` 数组的定义是**经过最多一条非树边**所能追溯到的最早节点。而 [pinkrabbit](https://www.cnblogs.com/PinkRabbit/p/10446473.html) 的则是**经过最多一条边**所能追溯到的最早节点。 这里采用了第二种写法，减少了很多特判情况。 记得两种方式弹栈都只是弹到把 $v$ 弹掉为止。$u$ 到 $v$ 之间可能还有一段节点，但不属于这个点双管辖。 ![](https://img2018.cnblogs.com/blog/1126418/201907/1126418-20190711015718548-2063534813.png) 看图会发现**在建圆方树的过程中，单边视作点双**。这是在点双定义是“不存在割点的图”的前提下的，正式定义貌似是任意两不同点之间都有至少两条点不重复的路径（忽略起点终点）。但是如果这样建并不方便做题，所以这里采用了前者定义建圆方树，这样每条边一定属于一个点双。 另外如果只是仙人掌，也可以一开始先建一棵搜索树，再枚举非树边，暴力跳 LCA 得到所有简单环。这应该是最直观的办法，好想好写。如果此时要用 Tarjan 算法并且还要访问环上的边，对每个点记父亲边，退栈时访问栈顶节点的所有出边找到那条连向 $u$ 的边。还要检查这个点双是不是一个单边，是则忽略这个点双。 建好了圆方树之后开始处理询问。首先先把每个方点的权值定义为与其相连的圆点的权值的最小值，这个可以用 `std::multiset` 来搞（因为圆点权值带修）。每个圆点修改时，修改所有与其相连的方点。 然而这在菊花图时会死。再考虑现在建出来的这棵圆方树的性质，圆方点内部互相之间都没有连边，所以以一个圆点为根的树应该是 圆——方——圆——方——圆 这样分层的。所以考虑让一个方点的 `std::multiset` 仅维护它的儿子圆点，而忽略它的父亲方点，也就是一个方点的权值表示为它的所有儿子圆点的权值的最小值。 这对询问的唯一影响就是，若 $u, v$ 的 LCA 是一个方点，那么还要算上这个方点的父亲圆点的值。 这样就可以树剖维护了。单点修改，路径查最小值，代码里用的是 zkw 线段树。 $O(n \log ^2 n)$。 # Code ```cpp #include #include #include using namespace std; const int maxN = 1e5 + 5; const int INF = 0x3F3F3F3F; int n, m, q, cnt, dfst; int val[maxN], low[maxN], dfn[maxN]; int ref[maxN < 1]; multiset y ? x = y, true : false; } template inline bool Chkmax(_Tp& x, const _Tp& y) { return x < y ? x = y, true : false; } namespace SEG { const int maxN = 2e5 + 5; int k; int MIN[maxN < 2]; inline void Pushup(int x) { Chkmin(MIN[x] = MIN[x < 1], MIN[x < 1 | 1]); } int Query(int l, int r) { int res = INF; for (l += k - 1, r += k + 1; l ^ r ^ 1; l >>= 1, r >>= 1) { if (~l & 1) Chkmin(res, MIN[l ^ 1]); if (r & 1) Chkmin(res, MIN[r ^ 1]); } return res; } void Modify(int u, int val) { MIN[u += k] = val; for (u >>= 1; u; u >>= 1) Pushup(u); } void Init() { for (k = 1; k]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>双连通分量</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF125E]MST Company]]></title>
    <url>%2Fblog%2FCF125E-MST-Company%2F</url>
    <content type="text"><![CDATA[--- title: '[CF125E]MST Company' tags: [凸优化, MST] categories: solution date: 2019-09-26 08:15:15 password: --- # Description 给定一个 $n$ 点 $m$ 边的图，以及参数 $k$，求在 1 号点度数强制为 $k$ 的情况下的最小生成树。 $$ 1 \le n \le 5000, 1 \le m \le 10 ^5, 1 \le w _i \le 10 ^5, 0 \le k < 5000 $$ # Solution ## hack 强烈谴责题目数据太水... 首先大部分的凸优化（或者说 wqs/带权二分）的做法都错了。这样只能正确的得到最小生成树的权值，但是要以此为基础构造方案会错。比如下面两组数据： ``` 5 8 3 1 2 7 1 4 8 1 5 7 1 3 3 2 3 1 3 5 1 3 4 10 4 5 3 ``` ``` 7 9 3 1 2 8 1 7 4 1 4 3 1 5 6 3 6 1 3 4 4 4 7 1 4 6 3 5 6 1 ``` 上面的最小生成树的权值是 19，下面的是 20。绝大多数程序会输出 20 和 -1... [可以证明](https://www.cnblogs.com/CreeperLKF/p/9045491.html) 在这种策略下做出的最小生成树即使度数超过 $k$，也必然可以通过换边来得到度数恰好为 $k$ 的生成树，并且权值一样（凸包上多点共线）。然而直接根据排序顺序并限制度数再去构造方案，很可能得到不连通或错误的结果。 ## 破圈 不妨考虑一个暴力一点的思路（$n$ 的范围较小）： 首先去掉 1 号点跑最小生成森林。 现在加入 1 号点。设此时除 1 号点外的联通块个数为 $x$，若 $k < x$，必然无解。 否则对于每个联通块加入能联通这个联通块的最小的边，这样就得到了一棵强制 $x$ 度生成树。 现在依然考虑经典的破圈算法： 对于一条不在生成树上的与 1 相连的边，若将其加到最小生成树中，其可以替换所产生的环上的一条最大的边，会使权值变小 $maxEdge - w$，其中 $maxEdge$ 是最大边边权，$w$ 是这条边的边权。 在所有 $maxEdge - w$ 找到其最大值并替换，在所替换的最大边不与 1 相连的前提下，就能得到一棵强制 $x + 1$ 度生成树。 将这个过程进行 $k - x$ 次，就能得到题目所要求的强制 $k$ 度生成树。 找到不与 1 相连的最大边由于数据范围原因可以暴力算。设 $maxE _i$ 表示在当前生成树上从 1 出发到 $i$ 节点的路径上**忽略与 1 相连的边**的最大边，每次 DFS 一遍 $O(n)$ 算就行。 $O(m \log m + nk)$ ## 二分 **虽然我本人感觉是对的，并且经过了上万组数据的对拍，但是因为数据湿度，这个做法依然可能会假，请谨慎阅读**。 现在这个构造法应该只能做这个题（强制 $k$ 度），另一道也需要二分的题（恰好有 $k$ 条白色边的最小生成树）无法用这个方法构造。 之前已经说了，二分最后得到的最小生成树中 1 的度数会大于等于 $k$。 先通过二分把这个生成树建出来，并固定 1 号点为根。 考虑枚举生成树之外的所有边用来替换那些与 1 相连的边，直到 1 号点度数为 $k$。假设当前边为 $(u, v)$，权值为 $w$，以及 $u$ 归属于 1 号点的儿子中 $p$ 的子树，$v$ 归属于 1 号点的儿子中 $q$ 的子树。 如果 $p = q$ 自然无可替换。否则，如果 $p, q$ 中任意一个点与 1 相连的边权是 $w$，那么这条边 $(1, p/q)$ 就可以被 $(u, v)$ 替换。不妨设可替换的边是 $(1, p)$，那么 $p$ 子树内的点需要全部接入 $q$（也即下一次查询 $p$ 子树内的点，得到结果应当为 $q$）。这是简单并查集操作。 另外边权**必须**恰好是 $w$，才可以替换。实际上因为已经是最小生成树了，不可能替换之后边权更小，证明中也提到了一定是边权相同的边导致了 1 的度数超出了 $k$，所以必须严格等于。 复杂度的话，二分部分为 $O(m \log m \log SIZE)$，其中 $SIZE$ 为值域大小。如果将与 1 相连的边与其他边每次归并排序或者桶排可以优化变为 $O(m \log SIZE)$。换边构树部分为 $O(m \log n)$。 # Code ## gen ```python from random import randint from cyaron import * import os n = 200 m = randint(n - 1, min(1e5, n * (n - 1) / 2)) k = randint(1, n - 1) outs = "%d %d %d\n" % (n, m, k) graph = Graph.UDAG(n, m, weight_limit = 1e2, self_loop=False, repeated_edges=False) outs += graph.to_str(); print(outs, file = open("tmp.in", "w")) ``` ## spj 需搭配 std 和 gen 食用 另外由于 python 玄学原因，每次只能运行 340 次... ```cpp #include #include using namespace std; using ptr = FILE*; const int maxN = 5e3 + 5; const int maxM = 1e5 + 5; int n, m, _ans, num, k; int fa[maxN], size[maxN]; struct Edge { int u, v, w; } edge[maxM]; int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); } inline bool Merge(int u, int v) { int fu = Find(u), fv = Find(v); if (fu == fv) return false; if (size[fu] > size[fv]) swap(fu, fv); fa[fu] = fv, size[fv] += size[fu]; return true; } inline void Err(const char* str) { fprintf(stderr, "%s\n", str); exit(0); } int main() { for (int cnt = 1; ; ++cnt) { system("python3 gen.py && ./tmp && ./std"); ptr in = fopen("tmp.in", "r"), out = fopen("tmp.out", "r"), ans = fopen("tmp.ans", "r"); int tmp; fscanf(in, "%d %d %d", &n, &m, &k); for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>MST</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2016]Nim z utrudnieniem]]></title>
    <url>%2Fblog%2FPOI2016-Nim-z-utrudnieniem%2F</url>
    <content type="text"><![CDATA[--- title: '[POI2016]Nim z utrudnieniem' tags: [DP] categories: solution date: 2019-09-24 10:47:15 password: --- # Description A 和 B 两个人玩游戏，一共有 $m$ 颗石子，A 把它们分成了 $n$ 堆，每堆石子数分别为 $a _{1, 2, \dots, n}$，每轮可以选择一堆石子，取掉任意颗石子，但不能不取。谁先不能操作，谁就输了。 在游戏开始前，B 可以扔掉若干堆石子，但是必须保证扔掉的堆数是 $d$ 的倍数，且不能扔掉所有石子。A 先手，请问 B 有多少种扔的方式，使得 B 能够获胜。 $$ 1 \le n \le 5 \times 10 ^5, 1 \le m \le 10 ^6, 1 \le d \le 10 \\\\ \texttt{Memory Limit = 64MB} $$ # Solution 考虑朴素 DP: 设 $f(i, j, k)$ 表仅考虑前 $i$ 堆石子，当前已经扔掉的堆数模 $d$ 为 $j$，且**扔掉的石子异或和**（注意这里和网上题解的状态定义有所区别）为 $k$ 的方案数。 考虑第 $i$ 堆选与不选，有转移： $$ f(i, j, k) = f(i - 1, j - 1, k \oplus a _i) + f(i - 1, j, k) $$ 复杂度 $O(nmd)$ 起飞了，考虑怎么优化。 异或运算有一个性质：一个数 $x$ 无论与比他小的数怎么异或，得到结果都小于 $2x$。利用二进制很容易得到。 所以先将石子堆按颗数排序，那么对于第 $i$ 堆石子而言，$k \ge 2 a _i$ 的状态必然毫无意义。于是只要将 $k$ 枚举到 $2 a _i - 1$ 即可，时间复杂度降为 $O(md)$。 再考虑空间限制。首先第一维可以滚动数组，但是还是超过了 64MB 的限制。 实际上，开滚动数组只是为了避免新状态转移到新状态。仔细考虑上述转移式，易得应当将 $j$ 从大到小，即从 $d - 1$ 到 1 枚举，这样可避免重复问题。为何省去了 0？因为 0 从 $d - 1$ 转移而来，所以开一个临时数组，转移之前先记下 $d - 1$ 这一维的情况，转移完 $d - 1 \to 1$ 之后再对 0 进行转移，可以省去滚动数组的空间。 由于题目要求不能全部扔掉，所以特判 $d | n$ 的情况，令答案减一即可。 时空复杂度 $O(md)$。 # Code ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-09-22 15:26 * FileName : wib.cpp * Website : https://endsah.cf * *******************************************************/ #include #include #include #include #define debug(...) fprintf(stderr, __VA_ARGS__) #define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s) #define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++) #define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch)) #define __bufsize (1 < 21 | 1) char _ibuf[__bufsize], _obuf[__bufsize], _stk[50]; char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk; struct END { ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } } __________; inline int read() { register int x = 0, flag = 1; register char ch; while (!isdigit(ch = getchar())) if (ch == '-') flag = -1; while (x = x * 10 + (ch & 15), isdigit(ch = getchar())); return x * flag; } template]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[APIO2019]路灯]]></title>
    <url>%2Fblog%2FAPIO2019-%E8%B7%AF%E7%81%AF%2F</url>
    <content type="text"><![CDATA[--- title: '[APIO2019]路灯' tags: [三维偏序] categories: solution date: 2019-09-24 10:45:43 password: --- # Description 一辆自动驾驶的出租车正在 Innopolis 的街道上行驶。该街道上有 $n + 1$ 个停车站点，它们将街道划分成了 $n$ 条路段。每一路段都拥有一个路灯。当第 $i$ 个路灯亮起，它将照亮连接第 $i$ 与第 $i + 1$ 个站点的路段。否则这条路段将是黑暗的。 安全起见，出租车只能在被照亮的路段上行驶。换言之，出租车能从站点 $a$ 出发到达站点 $b(a < b)$ 的条件是：连接站点 $a$ 与 $a + 1$，$a + 1$ 与 $a + 2$，……，$b - 1$ 与 $b$ 的路段都被照亮。 在经过一些意外故障或修理之后，街道上的路灯可能是亮起的，也可能是熄灭的。 现在给定 $0$ 时刻时，街道上路灯的初始状态。之后 $1, 2, \dots, q$ 时刻，每时刻会发生下列两种事件之一： + $\texttt{toggle}\ i$：切换第 $i$ 个路灯的状态。具体地说，若路灯原来亮起，则现在将熄灭；若路灯原来熄灭，则现在将亮起。 + $\texttt{query}\ a\ b$：出租车部门的负责人想知道，从 $0$ 时刻起到当前时刻，有多少个时刻满足：出租车能够从站点 $a$ 出发到达站点 $b$。 请你帮助出租车部门的负责人回答他们的问题。 $$ 1 \le n, q \le 3 \times 10 ^5 \\\\ \texttt{Time Limit = 5000ms} $$ # Solution 考虑一个很麻烦的东西：将所有形如 $a, b$ 的询问抽象为二维平面上的点 $(a, b)$，其点权即为询问答案。 如果在时刻 $t$ 将第 $i$ 盏路灯点亮，设 $l$ 为第 $i$ 个站点向左能延伸到的最远站点，$r$ 为第 $i$ 个站点向右能延伸的最远站点，那么便将所有 $x, y(x \in [l, i], y \in [i + 1, r])$ 的询问的权值便加上 $q + 1 - t$，表示在 $[t, q]$ 这段时间区间上 $x, y$ 这两个站点连通。熄灭同理，减去即可。 之前对上面的处理方式感到奇怪：如果如此计算，如果在加之后没有减，那么统计出的答案不会错吗？后来发现这是单点询问，所以这个情况相当于这个时刻 $x, y$ 连通，直接判一下减去 $q + 1 - t$ 即可。若当前时刻 $x, y$ 未连通，点权即询问答案。 连通用 `std::set` 维护，矩形加单点查还能离线，$\texttt{CDQ}$ 是很好的选择。 注意树状数组下标应该到 $n + 1$，不要将矩形的端点传错了参数（之前传的是两维的坐标区间，而不是矩形端点）。 $O(n \log ^2 n)$。 # Code 常数巨大... ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-09-24 08:03 * FileName : wib.cpp * Website : https://endsah.cf * *******************************************************/ #include #include #include #include using ptr = struct Oper*; #define debug(...) fprintf(stderr, __VA_ARGS__) #define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s) #define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++) #define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch)) #define __bufsize (1 < 21 | 1) char _ibuf[__bufsize], _obuf[__bufsize], _stk[50]; char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk; struct END { ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } } __________; inline int read() { register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = x * 10 + (ch & 15), isdigit(ch = getchar())); return x; } inline void read(char* str) { while (isspace(*str = getchar())); while (!isspace(*++str = getchar())) if (*str == EOF) break; *str = '\0'; } template 1 and y1 > 1) oper[++cnt] = Oper(x1 - 1, y1 - 1, val); } inline bool Cmp(const ptr& a, const ptr& b) { return a->x == b->x ? a->y > b->y : a->x > b->x; } namespace BIT { int sum[maxN]; inline void Add(int x, int addval) { while (x y - 1); } for (--j; ~j; --j) BIT::Add(L[j]->y, -L[j]->val); CDQ(l, mid), CDQ(mid + 1, r); } inline void Modify(int t, int i) { auto l = --pos.lower_bound(i), r = pos.upper_bound(i); if (pos.count(i)) { Add(*l + 1, i + 1, i, *r, q + 1 - t); pos.erase(i); } else { Add(*l + 1, i + 1, i, *r, t - q - 1); pos.insert(i); } } int main() { #ifndef ONLINE_JUDGE freopen("wib.in", "r", stdin); freopen("wib.out", "w", stdout); #endif n = read(), q = read(); read(start + 1); for (int i = 0; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>三维偏序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5599]失昼城的守星使]]></title>
    <url>%2Fblog%2FLuogu5599-%E5%A4%B1%E6%98%BC%E5%9F%8E%E7%9A%84%E5%AE%88%E6%98%9F%E4%BD%BF%2F</url>
    <content type="text"><![CDATA[--- title: '[Luogu5599]失昼城的守星使' tags: [树剖, 线段树] categories: solution date: 2019-09-17 15:52:05 password: --- # Description 给定一棵 $n$ 个节点的树，边有边权，每个节点初始有一个颜色（黑 / 白）。有 $m$ 个操作： `1 x`: 翻转 $x$ 节点的颜色。 `2 x y`: 询问所有黑色节点到 $x \to y$ 这条链上的距离之和。 （定义一个节点到链的距离为到链上节点距离的最小值） $$ 1 \le n, m \le 2 \times 10 ^5 $$ # Solution 有两种做法。先介绍一种细节少一点的，也较为优美的做法，第二种做法应该是标算。 ## First （应该）与标算不太一样，主要是实现上除了板子几乎没有细节。 首先随意定根。 一个点 $u$ 到链的距离等价于 $u$ 到这条链上 LCA 的距离减去 $u$ 到 LCA 的重合路径部分。这里的重合指的是 $u$ 到 LCA 的路径与这条链的重合部分。 考虑这个重合路径部分怎么算。类似 [ [LNOI2014]LCA ](https://www.luogu.org/problem/P4211) 的做法，重合部分显然等价于 $u$ 到根的路径与这条链的重合部分。将每个黑点到根的边全部打上一个 +1 的标记，每次直接查询这条链上的路径和即可。 （注意这里的 +1 是累加一次边权，不是权值 +1） 然后再考虑 $u$ 到这条链上 LCA 的距离。 现在设 LCA 为 $v$，拆一下可以得到 $dis (u, v) = dis _u + dis _v - 2 dis _{lca(u, v)}$（注意这里的 $dis(u, v)$ 是两点距离，$dis _u$ 是 $u$ 到根的距离） 用上面的修改方法一样能做，查询 $v$ 到根的路径上的路径和，即可得到 $\sum dis _{lca(u, v)}$。而 $\sum dis _u + dis _v$ 很容易维护（直接记当前有多少个黑点和黑点的 $dis$ 和），于是解决问题。 用 LCT 处理可以做到 $O(n \log n)$，不过懒得写了，$O(n \log ^2 n)$ 树剖就行。 虽然是一个比较奇怪的区间加（整体累加一次边权），不过大同小异，跟普通线段树没有什么区别。 ## Second 树剖之后，每个节点记录**除重儿子子树外**子树内黑点到当前节点的距离。 设链两端点为 $u, v$，其 LCA 为 $x$。首先考虑询问时，$x$ 的子树内的那些黑点的贡献怎么处理。 容易想到，因为每个节点忽略了重儿子子树，所以在跳链的时候，一段重链上的点权可以直接累加；而跨过轻链时，对于重链头的父亲节点 $y$，需要计算重儿子子树内的贡献，减去当前这个重链头的子树内的贡献。 注意这里减去加上的是整棵子树的贡献，不能忽略重儿子。 子树外的用 First 里说的统计就行。 ~~这个方法细节特别多所以我就不写了 而且我只是口胡出锅了不能找我负责~~ 如果想写这种做法的话去网上搜搜题解吧，这里只是一个大概的思路。 （大概看了下官方题解，没怎么看懂） # Code ## gen ```python from random import randint from cyaron import * import os cnt = 0 while True : n, m = int(2e5), int(2e5) outs = "%d %d %d\n" % (n, m, 0) tree = Graph.tree(n, weight_limit = 1e5) for i in tree.iterate_edges() : outs += "%d %d %d\n" % (i.start, i.end, i.weight) for i in range(n) : outs += "%d " % (randint(0, 1)) outs += '\n' for i in range(m) : if randint(0, 1) is 0 : outs += "1 %d\n" % randint(1, n) else : outs += "2 %d %d\n" % (randint(1, n), randint(1, n)) print(outs, file = open("tmp.in", "w")) os.system("./std && ./tmp") if os.system("diff tmp.out tmp.ans") : print("WA") exit() else : cnt += 1 print("AC %d times!" % cnt) ``` ## std ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-09-17 10:26 * FileName : tmp.cpp * Website : https://endsah.cf * *******************************************************/ #include #include #include #include using pii = std::pair; using LL = long long; #define fir first #define sec second #define debug(...) fprintf(stderr, __VA_ARGS__) #define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s) #define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++) #define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch)) #define __bufsize (1 < 21 | 1) char _ibuf[__bufsize], _obuf[__bufsize], _stk[50]; char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk; struct END { ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } } __; inline int read() { register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = x * 10 + (ch & 15), isdigit(ch = getchar())); return x; } template]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>树剖</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ2440]完全平方数]]></title>
    <url>%2Fblog%2FBZOJ2440-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[--- title: '[BZOJ2440]完全平方数' tags: [莫比乌斯反演, 容斥, 数论] categories: solution date: 2019-09-14 11:16:14 password: --- # Description $T$ 组数据。 每组数据给定 $k$，求出第 $k$ 个不是完全平方数的倍数的数。 $$ 1 \le T \le 50, 1 \le k \le 10 ^9 $$ # Solution 不是完全平方数的倍数，等价于 $\mu (x) \not = 0$。 可以先考虑二分一个 $x$，问题变为求出 $[1, x]$ 中有多少个 $i$ 满足 $\mu (i) \not = 0$。 考虑怎么算这个东西。 ## 直接构造并反演 设 $f(i)$ 表仅为 $i ^2$ 的倍数，且不为其他完全平方数的倍数的数的个数。数的上限为 $x$，也就是这些数不能超过 $x$。 **修正**：$f(i)$ 的意义应当为除掉 $i ^2$ 后不是一个大于一的完全平方数的倍数的数的个数。 再令 $F(i) = \sum \limits _{i | d} ^x f(d)$。可以得到 $F(i)$ 的意义为是 $i ^2$ 的倍数的数的个数，则 $F(i) = \lfloor \frac x {i ^2} \rfloor$。 直接进行莫比乌斯反演（这是个和平常不一样的反演，是 $i | d$ 而非 $d | i$）得到 $$ f(i) = \sum _{i | d} ^n \mu (\frac d i) F(d) $$ $f(1)$ 就是上面要求的（满足 $\mu(i) \not = 0$ 的）。则 $f(1) = \sum \limits _{d = 1} ^x \mu (d) \lfloor \frac x {i ^2} \rfloor$，因为出现了 $\lfloor \frac x {i ^2} \rfloor$，所以 $i$ 只需要枚举到 $\sqrt x$ 即可。 所以得到最终式： $$ \sum _{i = 1} ^{\lfloor \sqrt x \rfloor} \mu(i) \lfloor \frac x {i ^2} \rfloor $$ ## 利用莫比乌斯函数容斥 考虑求出 $[1, x]$ 之间不含平方因子的数的个数。 可以知道答案为 $x$ 减去 1 个素数的平方的倍数的数的个数 + 2 个素数的积的平方的倍数 - ... 可以发现这个容斥系数恰好为 $\mu$，因为 1 个素数减，2 个素数加，含平方因子数省略，很明显的 $\mu$ 的特征。 可以得到一个答案式： $$ x + \sum _{i = 2} ^{\lfloor \sqrt x \rfloor} \mu (i) \lfloor \frac x {i ^2} \rfloor = \sum _{i = 1} ^{\lfloor \sqrt x \rfloor} \mu (i) \lfloor \frac x {i ^2} \rfloor $$ 注意这里枚举 $i$ 的意义就是枚举数，不是枚举有多少个平方因子等七里八里的东西。 一样只需要枚举到 $\sqrt x$。 # Code ```cpp #include #include #include #include using namespace std; using LL = long long; const int maxN = 5e4 + 5; int T, k; int mu[maxN]; vector prim; bitset vis; void Shuffle(int n) { mu[1] = 1; for (int i = 2; i n) break; vis.set(x); if (i % j) mu[x] = -mu[i]; else break; } } } LL Getsum(LL x) { LL res = 0; for (LL i = 1, tmp = sqrt(x); i > T; Shuffle(50000); while (T--) { cin >> k; LL l = 1, r = k * 2, mid; while (l < r) { // cerr < l < ' ' < r < endl; mid = (l + r) >> 1; if (Getsum(mid) < k) l = mid + 1; else r = mid; } cout < l < endl; } return 0; } ```]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>容斥</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF342E]Xenia and Tree]]></title>
    <url>%2Fblog%2FCF342E-Xenia-and-Tree%2F</url>
    <content type="text"><![CDATA[--- title: '[CF342E]Xenia and Tree' tags: [根号分治] categories: solution date: 2019-09-14 10:02:33 password: --- # Description 给定一棵 $n$ 个节点的树，初始时 1 号节点为红色，其余为蓝色。 要求支持如下操作： 1. 将一个节点变为红色。 2. 询问节点 $u$ 到最近红色节点的距离。 共 $q$ 次操作。 $$ 1 \le n, q \le 10 ^5 $$ # Solution 点分树可以做，参考[洛咕题解](https://www.luogu.org/problemnew/solution/CF342E)。不过有比这更简单的做法。 有两种形式的暴力： 1. 对每个询问点，都和在其之前所有的红色点求 LCA 并计算出距离，再取最小值。 2. 对每个被修改为红色点的点，都在树上 BFS 并更新所有点到红色点的最小值。 这两个暴力各有优劣，如何把它们的优劣点综合起来？ 最常用的操作就是分块。 考虑对操作序列分块，设块大小为 $S$。 如何回答询问？ 首先对于在这个询问所属块之前的那些整块而言，每块都把所有的修改丢到队列里多源 BFS 一遍，每块复杂度 $O(n)$； 与这个询问在同一个块内的修改点，直接暴力求 LCA 并更新答案即可，复杂度 $O(S ^2 \log n)$。 总复杂度为 $O(n \cdot \frac m S + S ^2 \log n \cdot \frac m S)$，易知 $S$ 取 $\sqrt {\frac n {\log n}}$ 最优，此时总复杂度为 $O(m \cdot \sqrt {n \log n})$。 看起来这个复杂度很悬，实际上还会带上大约 $\frac 1 4$ 的常数，并且树剖的 $\log$ 根本跑不满，所以能轻松的过掉。 类似的分块思想的题今年 APIO 也出了，[[APIO2019]桥梁](https://www.luogu.org/problem/P5443)，可以再拿这题练下手。 # Code 一遍过了hhh ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-09-14 09:00 * FileName : wib.cpp * Website : https://endsah.cf * *******************************************************/ #include #include #include #include #include #include #define debug(...) fprintf(stderr, __VA_ARGS__) #define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s) #define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++) #define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch)) #define __bufsize (1 < 21 | 1) char _ibuf[__bufsize], _obuf[__bufsize], _stk[50]; char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk; struct END { ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } } __; inline int read() { register int x = 0, flag = 1; register char ch; while (!isdigit(ch = getchar())) if (ch == '-') flag = -1; while (x = x * 10 + (ch & 15), isdigit(ch = getchar())); return x * flag; } template]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演题解汇总]]></title>
    <url>%2Fblog%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E9%A2%98%E8%A7%A3%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[--- title: 莫比乌斯反演题解汇总 tags: [数论, 莫比乌斯反演, 杜教筛] categories: solution date: 2019-09-12 10:35:29 password: --- # Foreword 题目 + 题解 $(i, j) \Leftrightarrow \gcd (i, j)$ # [[SDOI2017] 数字表格]() ## Description ![](https://i.loli.net/2019/05/31/5cf11f83a888765118.png) $$ T \le 10 ^3, 1 \le n, m \le 10 ^6 $$ ## Solution 不妨设 $n \le m$ $$ \begin{aligned} & \prod _{i = 1} ^n \prod _{j = 1} ^m f((i, j)) \\\\ =& \prod _{d = 1} ^n \prod _{i = 1} ^n \prod _{j = 1} ^m [(i, j) = d] f(d) \\\\ =& \prod _{d = 1} ^n f(d) ^{\sum _{i = 1} ^n \sum _{j = 1} ^m [(i, j) = d]} \\\\ \end{aligned} $$ 指数部分提出来 单独计算 $$ \begin{aligned} & \sum _{i = 1} ^n \sum _{j = 1} ^m [(i, j) = d] \\\\ =& \sum _{i = 1} ^{\lfloor \frac n d \rfloor} \sum _{j = 1} ^{\lfloor \frac m d \rfloor} [(i, j) = 1] \\\\ =& \sum _{i = 1} ^{\lfloor \frac n d \rfloor} \sum _{j = 1} ^{\lfloor \frac m d \rfloor} \sum _{x | (i, j)} \mu (x) \\\\ =& \sum _{x = 1} ^{\lfloor \frac n d \rfloor} \mu (x) \lfloor \frac n {dx} \rfloor \lfloor \frac m {dx} \rfloor \end{aligned} $$ 考虑先枚举 $dx$ 的乘积再枚举 $d$ ，可以证明这样得出的答案不变（简易理解就是可以遍历到所有可能的 $d, x$ 的取值集合，不重不漏） ~~这应该也算是一种套路了~~ 令 $T = dx$ ，$x$ 可用 $\frac T d$ 代替 $$ \begin{aligned} & \prod _{T = 1} ^n \prod _{d | T} f(d) ^{\mu (\frac T d) \lfloor \frac n T \rfloor \lfloor \frac m T \rfloor} \\\\ =& \prod _{T = 1} ^n \left( \prod _{d | T} f(d) ^{\mu (\frac T d) } \right) ^{ \lfloor \frac n T \rfloor \lfloor \frac m T \rfloor} \end{aligned} $$ 预处理 斐波那契数列及其逆元 和 里面东西的前缀积，筛出 $\mu$ 之后直接枚举每个数对其倍数算贡献，复杂度 $O(n (\ln n + \log))$ （ $\log$ 是快速幂带的复杂度，这里 $\mu$ 只有三种取值，预处理逆元后就不需要快速幂了） 每次询问数论分块 + 快速幂，复杂度 $O(T (\sqrt n + \sqrt m) \log)$ ，其中 $T$ 是数据组数（注意逆元） ## Code ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-05-31 21:11 * FileName : SDOI2017_shuzibiaoge.cpp * Website : https://endsah.cf * *******************************************************/ #include #include #include #include #include typedef long long LL; #define debug(...) fprintf(stderr, __VA_ARGS__) #define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s) #define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++) #define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch)) #define __bufsize (1 < 21 | 1) char _ibuf[__bufsize], _obuf[__bufsize], _stk[20]; char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk; struct END { ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } } __; inline int read() { register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x < 3) + (x < 1) + (ch & 15), isdigit(ch = getchar())); return x; } template = 1; } return res; } inline void Pre(int n) { fib[1] = fibinv[1] = mu[1] = F[1] = F[0] = 1; for (register int i = 2; i n) break; vis.set(i * j); if (i % j) mu[i * j] = -mu[i]; else break; } } for (register int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数论</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ2138]stone]]></title>
    <url>%2Fblog%2FBZOJ2138-stone%2F</url>
    <content type="text"><![CDATA[--- title: '[BZOJ2138]stone' tags: [Hall 定理, 线段树] categories: solution date: 2019-09-02 20:31:06 password: --- # Description 有 $n$ 堆石子，$m$ 次操作。第 $i$ 次操作是在 $[l, r]$ 这堆石子中选出至多 $k$ 个石子扔掉。问在保证前 $i - 1$ 次操作全部最优（即扔掉石子最多）的前提下，第 $i$ 次操作最多能扔出多少石子。 **操作区间互不包含**。 设 $a _i$ 表第 $i$ 堆石子数目，则有： $$ 1 \le m \le n \le 40000, 1 \le a _i \le 500 $$ # Solution 比较巧妙的一道题... 操作之间互有影响，说明这不是一道简单的数据结构题，处理起来很麻烦。 看到 $a _i$ 的数据范围比较小，先考虑建立一个二分图匹配的模型：左部为石子，每堆石子拆为 $a _i$ 个石子，右部为操作，每次操作都相当于加入了 $k$ 个右部节点，这些右部节点每个节点均向那些所属堆在 $[l, r]$ 之内的石子连边。 问题变为在前面匹配数量不变的情况下，当前这些新加节点所能匹配的最大数量。 ~~网络流 + 线段树优化建边思博题~~这样复杂度太高了撑不住。 先想想前面的操作都能把其对应区间内石子全部扔掉的情况，也就相当于是**完全匹配**。 看到这个东西应该有一个敏感度：Hall 定理！ 如果不知道这里介绍一下： > Hall 定理：若二分图 $G = (S \cup T, E)$（不妨设 $|S| \le |T|$）满足任取 $S$ 子集 $X$ 均满足：对于与 $X$ 相邻（即与 $X$ 中节点有直接连边的 $T$ 部节点）的集合 $Y$，有 $|X| \le |Y|$，则二分图 $G$ 有完全匹配。 证明很简单： > 考虑反证。假设存在一个满足上述条件的二分图，且其最大匹配非完全匹配。 > > 那么左部肯定存在一个未匹配的点 $x$。根据 $|X| \le |Y|$，它至少和右部的一个点 $y$ 有连边。 > > 若 $y$ 没匹配过，那么 $x$ 和 $y$ 可以匹配，矛盾。 > > 若 $y$ 已有匹配，设 $y$ 和左边的 $z$ 点匹配，根据 $|X| \le |Y|$，点集 $\{x, z\}$ 与右边至少有两个点有连边，设除了 $y$ 之外的那个点为 $p$。 > > 再对 $p$ 进行类似讨论，递归地得到一定会存在一条增广路。这与最大匹配的定义矛盾，故得证。 在这题里并不需要考虑子集，只需要考虑连续堆即可，反正每 $k$ 个右部节点都会向同样的石子连边。 回顾一下之前的话： > 在保证前面完全匹配的情况下最优化当前答案。 也就是要在加入 $k$ 个右部节点之后任取左部区间（石子堆）$[i, j]$，均满足被这个区间 $[i, j]$ 所**包含**的那些操作的 $k$ 的总和比其小。 > 为什么要被 $[i, j]$ 包含？不是与 $[i, j]$ 中的某个点有连边（也就是相交）就行了么？ > > 考虑 Hall 定理的原意是枚举大小更小方（也就是右部节点）的集合，再统计与其相邻的左部集合的大小。这里反过来枚举左部区间，可以知道**在原来的枚举中，那些产生贡献的左部区间都会完全包含枚举的那些右部节点**。所以对于枚举的一个左部区间，只需统计那些被其包含的操作，相交的那些会被其他区间统计。 记 $s _i$ 为右端点 $\le i$ 的操作的 $k$ 的和，$p _i$ 为左端点 $\le i$ 的操作的 $k$ 的和。 上述条件等价于：（**操作区间互不包含**） $$ \forall 1 \le i \le j \le n, \sum _{l = i} ^j a _i \ge s _j - p _{i - 1} $$ 记 $S _i$ 表示 $\sum \limits _{j = 1} ^i a _j$，则有： $$ S _j - S _{i - 1} \ge s _j - p _{i - 1} \\\\ S _j - s _j \ge S _{i - 1} - p _{i - 1} $$ 再记 $f(i) = S _i - s _i, g(i) = S _i - p _i$，上式等价于 $$ \forall 1 \le i \le j \le n, f(j) - g(i - 1) \ge 0 $$ 留意 $f, g$ 是动态变化的。 再考虑当前增加了一个操作 $(l, r, k)$ 的影响。 **注意：从此开始 $k$ 改变意义，变为满足条件的情况下当前操作最多能扔掉的石子数**。可以看作只加入了这 $k$ 个右部节点，其他的直接删除，反正不会影响答案。 那么当前影响是：$\forall i \in [r, n], f(i) \gets f(i) - k$，$\forall i \in [l, n], g(i) \gets g(i) - k$。 由于仍要满足上面的那个式子，此时需要讨论几种 $i, j$ 取值情况，综合得到对 $k$ 的限制。 易知只有 $i \in [0, l - 1], j \in [r, n]$ 这部分根据 $k$ 的取值有可能变化。于是列出不等式： $$ \forall i \in [0, l - 1], j \in [r, n], f(j) - g(i) - k \ge 0 $$ 易得需满足 $k \le \min \limits_{j = r} ^n f(j) - \max \limits_{i = 0} ^{l - 1} g(i)$。显然取等号最优。 因为每次把那些剩下的右部节点直接删除，那么每次做完之后均为完全匹配，所以上述讨论一直成立。 于是用线段树维护 $f, g$ 即可，区间加和区间询问 $\min / \max$，$O(n \log n)$。 # Code ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-09-01 21:35 * FileName : wib.cpp * Website : https://endsah.cf * *******************************************************/ #include #include typedef long long LL; #define debug(...) fprintf(stderr, __VA_ARGS__) #define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s) #define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++) #define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch)) #define __bufsize (1 < 21 | 1) char _ibuf[__bufsize], _obuf[__bufsize], _stk[50]; char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk; struct END { ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } } __; inline int read() { register int x = 0, flag = 1; register char ch; while (!isdigit(ch = getchar())) if (ch == '-') flag = -1; while (x = (x < 3) + (x < 1) + (ch & 15), isdigit(ch = getchar())); return x * flag; } template lson->val, this->rson->val); } void Pushup_max() { Chkmax(this->val = this->lson->val, this->rson->val); } void Pushdown() { if (this->tag) { this->lson->Add(this->tag); this->rson->Add(this->tag); this->tag = 0; } } }; int fg; // flag / f and g ? whatever ptr f, g; void Build(int l, int r, ptr& cur) { cur = new Node(l, r); if (l == r) { cur->val = a[l]; return; } int mid = (l + r) >> 1; Build(l, mid, cur->lson), Build(mid + 1, r, cur->rson); fg ? cur->Pushup_max() : cur->Pushup_min(); } void Add(int ql, int qr, int addval, ptr cur) { if (ql l and cur->r Add(addval); return; } int mid = (cur->l + cur->r) >> 1; cur->Pushdown(); if (ql lson); if (mid < qr) Add(ql, qr, addval, cur->rson); fg ? cur->Pushup_max() : cur->Pushup_min(); } int Query(int ql, int qr, ptr cur) { if (ql l and cur->r val; int mid = (cur->l + cur->r) >> 1; cur->Pushdown(); int res = fg ? -INF : INF; if (ql lson)) : Chkmin(res, Query(ql, qr, cur->lson)); if (mid < qr) fg ? Chkmax(res, Query(ql, qr, cur->rson)) : Chkmin(res, Query(ql, qr, cur->rson)); return res; } } int main() { #ifndef ONLINE_JUDGE freopen("wib.in", "r", stdin); freopen("wib.out", "w", stdout); #endif n = read(); int x = read(), y = read(), z = read(), P = read(); for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Hall 定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[comet64D]系统设计]]></title>
    <url>%2Fblog%2Fcomet64D-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[--- title: '[comet64D]系统设计' tags: [哈希, 线段树二分] categories: solution date: 2019-09-01 21:32:22 password: --- # Description ![](/uploads/pic/2019-08-3010-22-48.png) $$ 1 \le n, m, q \le 5 \times 10 ^5 $$ 根不一定为 1。 # Solution [官方题解](http://static.eduzhixin.com/cometoj/solution/contest_61.pdf) 暴力就是按题意模拟。 仔细考虑这个模拟的过程。 ...**字符串匹配**？ 具体来说，把树上每个节点到根所经过的边的序号（边以编号大小排序）抽象成一个字符串，记作 $s _i$，将 $a _{l, \dots, r}$ 也抽象为字符串，那么相当于是找到一个最大的 $p$，满足 $\exists s _j = s _i + a _{l, \dots, p}$，$j$ 即为要输出的点。 可以配合官方题解的图看看。 因为 $p$ 显然具有单调性，所以如果没有修改，就可以直接预处理序列 $a$ 的前缀哈希值和树上节点的哈希值，并将树上结点的哈希值放入哈希表，查询直接二分 $p$，通过哈希值判断即可。 有修改用一个支持二分的数据结构维护即可。 下面的代码用的是 zkw 线段树，正常线段树或~~异常~~树状数组当然也可以。 注意放进哈希表的值也是哈希值，也就是说需要双哈希，一个用来在哈希表上寻址，一个最终用来比较是否一样。 当然为了稳也可以多哈希，比较是否一样时多比较几个哈希值即可。 实现里用了 `unsigned long long` 和 `1 < 24` 这两个模数，主要的好处是不用模，并且不用刻意的维护两个数，只要把 `unsigned long long` 模出来的值与一下 `(1 < 24) - 1` 就可以得到另一个哈希值。（因为 $2 ^{24} | 2 ^{64}$） DEBUG: 将 `int` 赋值为 `unsigned long long` 编译选项查不出来，拍了很久才拍出来... # Code ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-08-29 20:12 * FileName : wib.cpp * Website : https://endsah.cf * *******************************************************/ #include]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>线段树二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF464E]The Classic Problem]]></title>
    <url>%2Fblog%2FCF464E-The-Classic-Problem%2F</url>
    <content type="text"><![CDATA[--- title: '[CF464E]The Classic Problem' tags: [主席树, 最短路] categories: solution date: 2019-09-01 21:30:41 password: --- # Description 给定一个 $n$ 点 $m$ 边的无向图，边权均以为 2 的 $k$ 次幂的形式给出，求 $S$ 到 $T$ 的最短路 $1 \le n, k \le 10 ^5, 1 \le m \le 3 \times 10 ^5$ # Solution 首先还是必须用 Dijkstra 跑最短路的。 考虑中间复杂度爆炸的两种操作： ```cpp if (Chkmin(dis[v], dis[u] + w)) q.push(dis[v], v); ``` 主要是加法和比较的复杂度问题。暴力高精无论时间还是空间显然爆炸 考虑给每个点维护一个叶子节点全是 01 的线段树来代表当前节点的 `dis` 值。 如何比较两个 `dis` 值的大小关系？ 可以考虑把 01 序列像字符串一样找到 LCP（高位开始），比较 LCP 的最后一位就能知道他们之间的大小关系。 如何实现加法进位？ 首先这是单点加法。如果这一位是 0 直接变 1，如果是 1 则找到从当前位开始极长的一段连续的 1，将他们区间置 0，再在后一位变 1 就可以了。 如何保证复杂度？ 因为每个点的 `dis` 都是被某个点更新而来的，所以考虑主席树，区间置 0 的话直接把当前这个新树上那 $\log$ 段区间与其父亲断开连边，这样就不会影响历史版本状态了。也可以选择最开始建一棵全是 0 的线段树，直接把边连到这个线段树上就行。复杂度也是 $\log$，因为区间个数就这么多 每次开一个 `tmp` ，对这个 `tmp` 操作（单点置 1，区间置 0），然后如果 `Chkmin` 成功，直接 `root[v] = tmp` 即可。 比较和加法复杂度都是 $\cal O(\log k)$ 的（比较不需要空间，加法需要），然后 Dijkstra 过程需要 $\cal O((n + m) \log m)$ 次比较与加法，所以时空复杂度都是 $\cal O((n + m) \log m \log k)$ 的 代码参考了 hk 的，实现的很好，应当看看代码 # Code ```cpp #include #include #include #include using std::cin; using std::cout; using std::cerr; using std::endl; using std::vector; typedef std::pair pii; typedef long long LL; const int maxN = 1e5 + 2; const int lim = 1e5 + 80; const int mod = 1e9 + 7; int n, m, k, id, S, T, ans; int pw2[lim + 2]; vector G[maxN]; std::priority_queue q; std::bitset vis; inline int Mod(int x) { return x >= mod ? x - mod : x < 0 ? x + mod : x; } namespace SEG { int ncnt; int root[maxN]; int lson[maxN < 7], rson[maxN < 7], val[maxN < 7]; // node first, arrange second, and else. inline void Pushup(int cur, int l, int r) { int mid = (l + r) >> 1; cur[val] = Mod(cur[lson][val] + (LL)cur[rson][val] * pw2[mid - l + 1] % mod); } void Insert(int& cur, int pre, int l, int r, int pos) { cur = ++ncnt; if (l == r) { cur[val] = 1; return; } int mid = (l + r) >> 1; if (pos > T; pw2[0] = 1; for (int i = 1; i > v >> w; G[u].emplace_back(v, w), G[v].emplace_back(u, w); } for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF804F]Fake Bullions]]></title>
    <url>%2Fblog%2FCF804F-Fake-Bullions%2F</url>
    <content type="text"><![CDATA[--- title: '[CF804F]Fake Bullions' tags: [强连通分量, 计数, 思维] categories: solution date: 2019-09-01 21:28:55 password: --- # Description ![](/uploads/pic/2019-08-0817-23-14屏幕截图.png) # Solution 2019-8-4 这题很明显的有两问。第一问是处理出每个点取值的区间，第二问是计数。 首先处理这个边的条件。 $$ T \bmod S _u = T \bmod S _v \Leftrightarrow i \equiv j (\bmod \gcd(S _u, S _v)) \\\\ i = T \bmod S _u, j = T \bmod S _v $$ 这很好证。把 $T$ 分别写成 $aS _u + i$ 和 $bS _v + j$，对 $\gcd$ 取模后 $S _u, S _v$ 那两块都没了。 而 $i, j$ 就是 $u, v$ 两个联通块里的某个人。 考虑扩展这个结论，对于一条路径 $u \to v$，设其经过所有点的 $S$ 值的 $\gcd$ 为 $k$，对于 $u$ 中有金条的某个人 $i$ ，满足 $i \equiv j (\bmod k)$ 的 $j$ 都会被传一个假金条。 这也侧面证明，走一条边到 $v$ 比走路径到 $v$ 产生的贡献更优一些。 而且如果我们将一个强连通分量视为一个大点，其人数为里面小点人数的 $\gcd$，那么里面的所有点对外面的贡献等价于这个强连通分量对外面点的贡献。 于是缩点，一个强连通分量的金块分布情况用那个同余的式子算（把里面所有小点都对它算一遍），就可以在竞赛图的哈密顿路上转移（竞赛图缩完点还是竞赛图）。 为什么要在哈密顿路上转移？ 这样可以前缀累计贡献，即第一个点的贡献累加到第二个点，第二个点带着第一个点的贡献累加到第三个点，等等。于是此时就只要考虑 $i, i + 1$ 这两个点之间的边（这里 $i$ 是指哈密顿路上的编号），用同余的式子转移即可。 转移完后每个小点的金块数就是 $x * \frac {S _u} k$，$x$ 为其所在强连通分量的金条数。 第一问就做完了。每个点下界就是一开始有的金条，上界就是算完之后的金条数。 第二问： 考虑枚举一个点 $u$，强制其为 $B$ 集合中最小的点（有多个取编号最大，避免算重）。 由于对于一个确定的 $A$ 集合，里面的点取最大值并不会影响其与其他点的大小关系，所以对 $A$ 集合直接讨论上界 $r$。 然后算出 $l _i > r _u$ 的点数 $a$，$r _i \ge r _u \ge l _i$ 的点数 $b$，枚举在 $b$ 里选了多少个算组合数就行。由于 $A$ 限制了 $x$ 的上界，所以不能范德蒙德卷积，得一个个老实算。 注意枚举边界。直接在组合数里防边界也可以。 # Code ```cpp #include #include #include typedef long long LL; using namespace std; const int maxN = 5e3 + 2; const int mod = 1e9 + 7; int n, a, b, dfst, colcnt, ans; int dfn[maxN], low[maxN], col[maxN], minn[maxN], maxx[maxN]; // point int gcd[maxN], cnt[maxN]; // SCC int fac[maxN]; // math stack stk; vector G[maxN]; // graph, not g vector tmp, F[maxN]; string S[maxN]; inline bool Chkmin(int& x, int y) { return x > y ? x = y, true : false; } inline void Mod(int& x) { x >= mod ? x -= mod : 0; } inline int GCD(int x, int y) { while (y) std::swap(x, y), y %= x; return x; } inline int Qpow(int a, int n) { if (a == 1) return 1; if (n == -1) return Qpow(a, mod - 2); int res = 1; while (n) { if (n & 1) res = (LL)res * a % mod; a = (LL)a * a % mod; n >>= 1; } return res; } void Tarjan(int u) { dfn[u] = low[u] = ++dfst; stk.push(u); for (int v : G[u]) { if (!dfn[v]) Tarjan(v), Chkmin(low[u], low[v]); else if (!col[v]) Chkmin(low[u], dfn[v]); } if (low[u] == dfn[u]) { ++colcnt; col[u] = colcnt, gcd[colcnt] = S[u].size(); while (stk.top() != u) { int v = stk.top(); stk.pop(); col[v] = colcnt, gcd[colcnt] = GCD(gcd[colcnt], S[v].size()); } stk.pop(); } } inline int C(int n, int m) // C _n ^m { return (LL)fac[n] * Qpow(fac[m], -1) % mod * Qpow(fac[n - m], -1) % mod; } int main() { #ifndef ONLINE_JUDGE freopen("wib.in", "r", stdin); freopen("wib.out", "w", stdout); #endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin >> n >> a >> b; for (int i = 1; i > S[1]; for (int j = 1; j sth >> S[i]; } for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>强连通分量</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1172E]Nauuo and ODT]]></title>
    <url>%2Fblog%2FCF1172E-Nauuo-and-ODT%2F</url>
    <content type="text"><![CDATA[--- title: '[CF1172E]Nauuo and ODT' tags: [LCT] categories: solution date: 2019-09-01 21:27:27 password: --- # Description 给定一棵 $n$ 个点的树，每个节点有颜色。求 $$ \sum _{i = 1} ^n \sum _{j = 1} ^n f(i, j) $$ 其中 $f(i, j)$ 表 $i$ 到 $j$ 路径上的颜色种数。 有 $m$ 次修改，对于初始状态和每次修改都需回答上式结果。 **修改之间互有影响**。 $$ 1 \le n, m \le 2 \times 10 ^5 \\\\ colcnt \le n $$ 2019-08-14 [CF1172E Nauuo and ODT](http://codeforces.com/problemset/problem/1172/E) # Solution 首先看 $m = 0$，即没有修改怎么做。 可以暴力 $n ^2$ 找到所有路径并统计，于是有一个自然的思路：固定一个端点然后统计答案。 但实际上这个做法并没有什么前途，所以只能换一种考虑方式：计算每种颜色对答案的贡献。 显然贡献为**至少经过一个这个颜色的点**的路径条数。 这等价于所有路径（$n ^2$）减去**不经过这个颜色的点的路径条数**（$\sum size ^2$），其中 $size$ 为去掉这个颜色的点后，树上的联通块的个数。 在树上把这种颜色的点视作白色，不是这种颜色的点视作黑色，问题变为求所有黑色联通块 $size ^2$ 之和。 看起来很有前途！ 然后你会发现这个做法貌似 $m = 0$ 都做不了。 但实际上，对于这个思路来说，**初始状态是操作了 $n$ 次的状态**，所以 $m = 0$ 这个东西不重要。 于是可以继续深入思考，首先修改颜色对某种颜色要么不影响，要么是一次 黑->白 或者 白->黑。因为要统计黑色联通块 $size ^2$，带修+树上问题，LCT 没跑了。 LCT 只能断边连边，所以可以将所有黑点向原树父亲连边而白点不连（定 1 为根，1 的父亲视作一个虚点，比如 $n + 1$），翻转颜色就是断/连边过程了。刚好这样做也利于答案统计，对于白点，它的所有子节点都是黑点，统计所有白点虚子树大小平方和就行。这个用 LCT 可以维护。 [官方题解里有详解图](https://www.luogu.org/problemnew/solution/CF1172E) ![](https://i.loli.net/2019/06/08/5cfb4d7d77b8678330.png) 但是不能对每个颜色都开 LCT 算，复杂度会炸。 可以发现总共就 $n + m$ 次操作，于是把 $m$ 次修改离线下来，一开始初始化一棵全是黑点的 LCT（即所有点向原树父亲连边，1 向 $n + 1$ 连边），对每个颜色都进行那些影响了这个颜色的操作，最后再倒着改回来就行了。这样修改总次数就是 $\cal O(n + m)$ 的，复杂度才是对的。 对于每次操作算出来的答案会一直贡献到下一次操作为止，于是记录下每个操作在长度为 $n + m$ 的操作序列上的位置，差分统计就可以了。 $\cal O((n + m) \log n)$ 因为 LCT 的 `Rotate` 错了调了一年... 板子不敲熟真的太致命了... ```cpp if (~curfa->Ident()) // curfa->fa->son[this->Ident()] = this; curfa->fa->son[curfa->Ident()] = this; ``` # Code ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-08-15 19:03 * FileName : color.cpp * Website : https://endsah.cf * *******************************************************/ #include #include #include #include typedef long long LL; typedef std::pair pii; typedef struct Node* ptr; #define fir first #define sec second #define debug(...) fprintf(stderr, __VA_ARGS__) #define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s) #define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++) #define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch)) #define __bufsize (1 < 21 | 1) char _ibuf[__bufsize], _obuf[__bufsize], _stk[50]; char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk; struct END { ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } } __; inline int read() { register int x = 0, flag = 1; register char ch; while (!isdigit(ch = getchar())) if (ch == '-') flag = -1; while (x = (x < 3) + (x < 1) + (ch & 15), isdigit(ch = getchar())); return x * flag; } template size : 0; } void Pushup() { this->size = Size(this->son[0]) + Size(this->son[1]) + this->virt + 1; } void Rotate() // attention! this->Pushup() disappear! { ptr curfa = this->fa; int dir = this->Ident(); if (~curfa->Ident()) curfa->fa->son[curfa->Ident()] = this; if (this->son[dir ^ 1]) this->son[dir ^ 1]->fa = curfa; curfa->son[dir] = this->son[dir ^ 1], this->son[dir ^ 1] = curfa; this->fa = curfa->fa, curfa->fa = this; curfa->Pushup(); } void Splay() { ptr curfa; while (~this->Ident()) { curfa = this->fa; if (~curfa->Ident()) curfa->Ident() ^ this->Ident() ? this->Rotate() : curfa->Rotate(); this->Rotate(); } this->Pushup(); } }; inline void Access(ptr cur) { for (ptr son = nullptr; cur; son = cur, cur = cur->fa) { cur->Splay(); (cur->virt += Node::Size(cur->son[1])) -= Node::Size(son); cur->vir_2 += (LL)Node::Size(cur->son[1]) * Node::Size(cur->son[1]); cur->vir_2 -= (LL)Node::Size(son) * Node::Size(son); cur->son[1] = son; } } inline ptr Findroot(ptr cur) { Access(cur), cur->Splay(); while (cur->son[0]) cur = cur->son[0]; cur->Splay(); return cur; } inline void Link(int u) { ptr cur = root + u, curfa = root + fa[u]; Access(cur), ans += cur->vir_2; ptr currt = Findroot(curfa); Access(currt), ans += currt->vir_2; Access(curfa), curfa->Splay(); cur->fa = curfa; curfa->virt += cur->size; curfa->vir_2 += (LL)cur->size * cur->size; curfa->size += cur->size; Access(currt), ans -= currt->vir_2; } inline void Cut(int u) { ptr cur = root + u, curfa = root + fa[u], currt = Findroot(cur); Access(currt), ans += currt->vir_2; Access(curfa), curfa->Splay(); curfa->virt -= cur->size; curfa->vir_2 -= (LL)cur->size * cur->size; curfa->size -= cur->size; cur->fa = nullptr; Access(cur), ans -= cur->vir_2; Access(currt), ans -= currt->vir_2; } void DFS(int u) { for (int v : G[u]) if (v != fa[u]) fa[v] = u, DFS(v); } int main() { #ifndef ONLINE_JUDGE freopen("color.in", "r", stdin); freopen("color.out", "w", stdout); #endif n = read(), m = read(); root = new Node[n + 2]; for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2015]运输计划]]></title>
    <url>%2Fblog%2FNOIP2015-%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[--- title: '[NOIP2015]运输计划' tags: [二分答案, 树上差分] categories: solution date: 2019-09-01 21:25:49 password: --- # Description ![](/uploads/pic/2019-08-3015-53-23.png) $$ 1 \le n, m \le 3 \times 10 ^5 $$ # Solution 怀念以前 NOIP 的难度... 默认以 1 为根，且化边权为点权。1 的点权未定义。 答案显然有单调性，于是二分答案 $p$。 那么航道长度大于 $p$ 的都至少需要一个虫洞，故把这些航道拿出来单独考虑。 首先这个虫洞显然会建在这些航道路径的**交集**上。 这个可以用树上差分很方便的维护。具体地，将每条航道的两个端点打上 +1 标记，lca 打上 -2 标记（已化边为点），最后统计子树和，如果一个点子树标记和与这些长度大于 $p$ 的航道的路径条数相等（即所有航道全部经过了这个点与其父亲之间的连边），那么它与其父亲所连的这条边在交集中。 考虑选交集中的哪条边最优。因为只能选一条，易得一定是选边权最大的那条。 然后就做完了。~~（感觉我在水）~~ # Code ## std ```cpp #include #include #include #include const int maxN = 3e5 + 2; int n, m, ecnt; int head[maxN], st[maxN], ed[maxN], lca[maxN], len[maxN]; int top[maxN], size[maxN], dep[maxN], son[maxN], wet[maxN], fa[maxN], dis[maxN]; int tag[maxN]; int next[maxN < 1], to[maxN < 1], val[maxN < 1]; inline bool Chkmax(int& x, int y) { return x < y ? x = y, true : false; } inline int read() { int x = 0; char ch; while (!isdigit(ch = getchar())); while (x = (x < 3) + (x < 1) + (ch & 15), isdigit(ch = getchar())); return x; } inline void Link(int u, int v, int w) { ++ecnt; next[ecnt] = head[u], to[ecnt] = v, val[ecnt] = w; head[u] = ecnt; } void DFS1(int u) { size[u] = 1; for (int i = head[u]; i; i = next[i]) { int v = to[i]; if (v == fa[u]) continue; fa[v] = u; dep[v] = dep[u] + 1, wet[v] = val[i], dis[v] = dis[u] + val[i]; DFS1(v); size[u] += size[v]; if (size[v] > size[son[u]]) son[u] = v; } } void DFS2(int u) { if (son[u]) top[son[u]] = top[u], DFS2(son[u]); for (int i = head[u]; i; i = next[i]) { int v = to[i]; if (!top[v]) top[v] = v, DFS2(v); } } int LCA(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] < dep[top[v]]) std::swap(u, v); u = fa[top[u]]; } return dep[u] > dep[v] ? v : u; } void Getsum(int u) { for (int i = head[u]; i; i = next[i]) { int v = to[i]; if (v != fa[u]) Getsum(v), tag[u] += tag[v]; } } bool Check(int lim) { int cnt = 0, max = 0, maxx = 0; memset(tag + 1, 0, n * sizeof(int)); for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CTS2019]重复]]></title>
    <url>%2Fblog%2FCTS2019-%E9%87%8D%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[--- title: '[CTS2019]重复' date: 2019-09-01 21:22:06 tags: [KMP 自动机, 计数] categories: solution password: --- # Description 给定一个小写字符串 $s$。问有多少个不同的长度为 $m$ 的串 $t$，满足将 $t$ 无限重复之后，可以从中找出一个长度与 $s$ 相同且字典序小于 $s$ 的串。 设 $s$ 长度为 $n$，则满足 $$ 1 \le n, m \le 2000 $$ # Solution 正难则反，考虑对不满足上面条件的串计数。 不满足条件等价于将 $t$ 无限重复之后任意长度为 $n$ 的子串字典序均大于等于 $s$。 下文中称不满足条件的为**合法**串。注意定义与题目定义相反。 考虑建一个自动机用来唯一接受这些合法串。 对 $s$ 建 KMP 自动机。如果你不知道可以脑补一下补边的 AC 自动机只有一个模式串的样子，就是补齐了 26 条转移边的那种。 首先需要明确 KMP 自动机原本的作用。把一个文本串放到 $s$ 所建立的 KMP 自动机上跑，跑到的节点代表的意义是文本串的后缀与 $s$ 的前缀的最长匹配。这个节点便代表了 $s$ 的那个前缀。 考虑有了字典序的限制之后，这个 KMP 自动机该如何变化。 结论：**一个节点不是到根的转移边中，只能保留字符最大的那条**，并且字符比这条小的到根的也不能保留。 假设当前匹配到的前缀节点字符最大的那条转移边为 `'k'`。那么这个前缀节点表示的串应该是这个样子：`str + 'k' + ?? + str`。`str` 表示相同的前缀后缀，`??` 表示中间一堆乱七八糟的字符串。 比如当前匹配到 `akabaka` 这个前缀节点，其 `'k'` 边最大，表示出来就是 `"a" + 'k' + "abak" + "a"`。自动对应上 `str` 和 `??` 就行。 假如现在走了一条比 `'k'` 小的转移边。那么用 `str` 拼上这个字符，便可以得到一个字典序比 `str + 'k'` 小的串，那么以这个串为开头的串就会比 $s$ 小，所以不合法。 在删掉一些边之后，可以保证在这个自动机上跑出来的字符串都是合法的了。现在考虑怎样对这种合法的字符串计数。 因为这个字符串可以无限重复，也就是说这个字符串一定在这个自动机的环上一直绕。 ...从一个节点出发长度为 $m$ 的环？ 现在考虑一个合法的字符串 $t$，并先假设 $n < m$。 那么把 $t$ 放到这个删边之后的自动机上跑，**跑完所到的点应当与删边之前跑完所到的点一样**。作为一个合法的字符串，它所走的转移边都没有被删掉。 删边之前是一个 $s$ 所建的 KMP 自动机，所以这个节点所代表的前缀应当是最长的与 $t$ 的某个后缀能匹配的前缀。 因为 $n < m$，所以再接一个 $t$ 串之后，$t + t$ 与 $s$ 的**能匹配的最长后前缀不变**。所以再走一次 $t$，仍会走到相同的节点去。 所以当 $n < m$ 时，一个合法的 $t$ 一定是从一个节点出发走一个长度为 $m$ 的环然后回到这个节点。 $n \ge m$ 同理。匹配时会先走到几个零散的点，直到用 $t + t + t + \cdots$ 拼出的串长度大于 $s$ 时，又会是从一个点走 $m$ 步的环回到这个点。 起点一样走的边不同一定对应了不同的字符串，那么还需要证明没有两个长度为 $m$，起点不一对应字符串却完全一样的环。这很好证，因为一个合法 $t$ 只可能在 KMP 自动机上对应一个前缀节点，这种情况相当于 $t$ 对应了两个前缀节点，这是不现实的。 于是现在问题变成：在一个只保留一条转移边的 KMP 自动机上计算从每个节点出发长度为 $m$ 的环。 因为这个 KMP 自动机形状比较特殊，一个节点只有一条出边和若干条到根的边，大概长成这样： ![](/uploads/pic/o_无标题.png) $\rho$ 的样子。当然后面还有一些节点，但是与根不连通，省略了。~~如果你觉得基环内向树好理解也可以按基环内向树理解~~。 于是设 $f(i, j)$ 表根走 $i$ 步到 $j$ 的方案数，$g(i, j)$ 表 $j$ 走 $i$ 步到根的方案数，有转移： $$ f(i + 1, v) \gets f(i, u) \\\\ f(i + 1, 0) \gets f(i, u) \times edge _u \\\\ g(i + 1, u) \gets g(i, v) $$ $edge _i$ 表示 $i$ 出发到根的那些转移边。注意 $g$ 的转移保证仅经过一次根节点，所以不会算重。 最后枚举走 $j$ 步到根，自然就走 $m - j$ 步再到自己，方案数相乘即可。 再看 $\rho$ 的那个环的大小是否为 $m$ 的约数，如果是，加上环的大小。 再用 $26 ^m$ 减去即得到答案。 生成函数的到时候再更。 # Code ```cpp #include #include #include using namespace std; using LL = long long; const int maxN = 2e3 + 5; const int mod = 998244353; int n, m, circle_len, ans; char str[maxN]; int edge[maxN], v[maxN], fail[maxN], dep[maxN]; bool vis[maxN]; int f[maxN][maxN], g[maxN][maxN]; inline void Mod(int& x) { x >= mod ? x -= mod : x < 0 ? x += mod : 0; } int QPow(int bas, int ind) { int res = 1; while (ind) { if (ind & 1) res = (LL)res * bas % mod; bas = (LL)bas * bas % mod; ind >>= 1; } return res; } void DFS(int u) { vis[u] = true; if (vis[v[u]]) circle_len = dep[u] - dep[v[u]] + 1; else dep[v[u]] = dep[u] + 1, DFS(v[u]); } int main() { #ifndef ONLINE_JUDGE freopen("wib.in", "r", stdin); freopen("wib.out", "w", stdout); #endif cin >> m >> (str + 1); n = strlen(str + 1); fail[1] = 0; for (int i = 2, j = 0; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>KMP 自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1188D]Make Equal]]></title>
    <url>%2Fblog%2FCF1188D-Make-Equal%2F</url>
    <content type="text"><![CDATA[--- title: '[CF1188D]Make Equal' date: 2019-09-01 21:19:13 tags: [数位, DP] categories: solution password: --- # Description ![](/uploads/pic/2019-08-2121-52-32屏幕截图.png) 2019-8-8 # Solution 设最终所有数相等时它们均为 $p$，$a _i$ 中的最大值为 $v$。显然 $p \ge v$。 那么答案即 $\sum \limits _{i = 1} ^n \phi(p - a _i)$，$\phi(i)$ 表二进制位表示下 $i$ 中 1 的个数。 再设 $t = p - v, b _i = v - a _i$。显然有 $p - a _i = t + b _i$。 然后问题变为：最小化 $\sum \limits _{i = 1} ^n \phi (t + b _i)$。 想象一下：把 $b _i$ 二进制表示出来然后列成 $n$ 行，这应该是一个 $n$ 行 $60$ 列的 01 矩阵，60 列是二进制下 60 位。以下说到第多少位可以在脑子里对应到矩阵的第几列上去。 所有 $b _i$ 都得加 $t$，抽象到矩阵上就是 60 列每列都有一个选择：这一列全部加 1 还是不动（加 1 相当于 $t$ 在这一位上有一个 1）。 设 $T _i$ 表第 $i$ 位的长度为 $n$ 的 01 集合。 因为有进位的影响，所以可以从低位到高位 DP: $F _{i, S}$ 表决策完了第 $i$ 列之前的加 1 还是加 0，第 $i$ 位向后进位情况为 $S$（一个集合）时，最少的 1 的个数。这里的 1 的个数是指 $i$ 位前的那个 $n$ 行 $i$ 列的**修改过后**的矩阵的 1 的个数。 初始状态：$F _{0, 0} = \phi(T _0), F _{0, T _0} = n - \phi(T _0)$。 有转移：（$\and = {\rm and}, \or = {\rm or}, \oplus = {\rm xor}$） $$ F _{i + 1, S \and T _{i + 1}} \gets F _{i, S} + \phi(T _{i + 1} \oplus S)\\\\ F _{i + 1, S \or T _{i + 1} }\gets F _{i, S} + n - \phi(T _{i + 1} \oplus S) $$ 分别是在第 $i + 1$ 行 +0 和 +1 的两种决策。取 min 即可。 时空复杂度 ${\cal O(\log \max \{a _i\}} 2 ^n)$。这个复杂度不太行。 DP 还是不要动，但是状态貌似没必要记这么多。若是在考虑第 $i + 1$ 位时将 $n$ 个数按当前前 $i$ 位的值排序，可以发现**进位的那些数一定是一个前缀**。因为只有整体加，所以不可能有一个比自己小的进了位自己却没进。 于是更改状态：$F _{i, j}$ 表前 $i$ 位数，按前 $i$ 位排序后第 $1 - j$ 大的数要向后进位时，最少的 1 的个数。注意 $j$ 可以等于 0。 那么有一个新的转移： $$ F _{i + 1, p _{j}} \gets F _{i, j} + (j - p _j) + s _{j + 1} \\\\ F _{i + 1, j + s _{j + 1}} \gets F _{i, j} + p _j + (n - j - s _{j + 1}) $$ $p _j, s _j$ 分别是在当前从大到小排序后到 $j$ 的前缀/后缀的 1 的个数。 上下两行分别是 +0 和 +1。$j - p _j$ 就是 $j$ 前有多少个 0，$n - j - s _{j + 1}$ 就是 $j + 1$ 后有多少个 0。画个图看看就能知道转移了。 现在时空复杂度变为 ${\cal O(n \log n \log \max \{a _i\})}$。要基数排序优化那个 $\log n$ 也可以，代码里面没写。 # Code ## BF ```cpp Chkmin(F[0][0], phi(T[0])); Chkmin(F[0][T[0]], n - phi(T[0])); for (int i = 0; i < 60; ++i) for (int S = (1 < n) - 1; ~S; --S) if (F[i][S] != INF) { Chkmin(F[i + 1][S & T[i + 1]], F[i][S] + phi(T[i + 1] ^ S)); Chkmin(F[i + 1][S | T[i + 1]], F[i][S] + n - phi(T[i + 1] ^ S)); } ``` ## std ```cpp #include > n; for (int i = 1; i > a[i]; Chkmax(v, a[i]); } for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JLOI2015]骗我呢]]></title>
    <url>%2Fblog%2FJLOI2015-%E9%AA%97%E6%88%91%E5%91%A2%2F</url>
    <content type="text"><![CDATA[--- title: '[JLOI2015]骗我呢' date: 2019-09-01 20:52:58 tags: [组合, 计数, 容斥] categories: solution password: --- # Description ![](/uploads/pic/2019-08-2519-32-47屏幕.png) $$ 1 \le m, n \le 10 ^6 $$ 2019-8-7 # Solution [图源](https://www.cnblogs.com/xzyxzy/p/9812585.html) 代码简单调都不用调，想要想一年... 根据题目条件，每行肯定是 0 到 $m$ 的中去掉一个数组成的有序数列。 另一个条件通过手模或者显然也可以得到：当前行去掉的那个数不能小于上一行去掉的数 - 1。 到这里就可以考虑一个 DP: 设 $f(i, j)$ 表仅考虑前 $i$ 行，第 $i$ 行删去的数为 $j$ 时的方案数。 有转移： $$ f(i, j) = \sum _{k = 0} ^{j + 1} f(i - 1, k) $$ 特别明显的前缀和形式，改写一下： $$ f(i, j) = f(i - 1, j + 1) + f(i, j - 1) $$ 特别地，$f(i, 0) = f(i - 1, 1), f(1, j) = 1, f(i, m) = f(i, m - 1)$。 这时候已经可以做到 $n ^2$ 了。但是这个式子和组合数递推的式子比较相似，所以看看组合意义上怎么优化。 把转移边画出来： ![](/uploads/pic/iwUEt0.png) $n$ 行 $m + 1$ 列。一一对应上就行。 这个斜边好像不太好。整个的倾斜一下，然后补一下虚拟节点免得转移漏了（因为 $f(i, 0)$）： ![](/uploads/pic/iwUwBd.png) ...路径数？ 用 $f(i, j)$ 表示从最左上角出发走那些转移边（虚线也算）到 $(i, j)$ 这个点的路径数。 可以发现这个定义和之前的定义是等价的。 最终答案应该是 $\sum \limits_{j = 0} ^m f(n, j)$，所以再补一行，$f(n + 1, m)$ 即为答案。 （$f(n + 1, m) = f(n + 1, m - 1) = \sum \limits _{j = 0} ^m f(n, j)$） 因为这个形状比较特殊，可以发现只走转移边和不碰到左边右边两条直线是等价的（上面图还没画，不过应该感觉的到） 再给它对称一下丢到坐标系上。 ![](/uploads/pic/1449755-20180829123026113-567524378.png) 这应该就看的很清楚了。 两条直线分别是：$A: x - y + 1 = 0, B: x - y - m - 2 = 0$。 **求从 $(0, 0)$ 出发到 $(n, n + m + 1)$，且不接触 $A, B$ 两条直线的路径数。** 这里需要容斥计数。首先没有限制显然 ${2n + m + 1}\choose{n}$。 再考虑不合法方案。把不合法方案碰到的直线（与上次碰到的相同的略去）序列用来表示这种方案。如 $ABA$ 表示经过 $A$ 后再过 $B$ 再过 $A$。 关于这方面有一个（经典的？）**翻折法**。 将终点关于某条直线的对称点视作终点，那么**到这个新终点的路径条数就等于到原终点经过了这条直线的路径条数**。 叫翻折法的原因大概是把作对称点的过程视作沿直线翻折过去。 一定会经过这条直线这点易证。在这题而言，还有一个性质： 沿 $A$ 翻折之后到新终点的路径条数一定由 $A$ 结尾或 $AB$ 结尾。 看下图： ![](/uploads/pic/0060lm7Tly1fwcmwpd2irj30id0gudgm.jpg) 这是一条满足以 $A$ 结尾的路径。 ![](/uploads/pic/0060lm7Tly1fwcmwqn12rj30j60i4jsb.jpg) 这是一条满足以 $AB$ 结尾的路径。 这应该挺显然的... 要证也可以证。因为到这个新终点一定会经过 $A$，而且可能经过不止一次。考虑某条路径最后与 $A$ 的交点，最后与 $A$ 相交后要么碰到 $B$ 要么碰不到，所以结尾一定是 $A$ 或 $AB$。 现在考虑不合法的方案有两种：以 $A$ 开头和以 $B$ 开头的。 $A$ 开头的可能：$A, AB, ABA, ABAB, ABABA\cdots$。要容斥就是减 $A$ 和 $AB$ 结尾，加 $BA$ 和 $BAB$ 结尾，减 $ABA$ 和 $ABAB$ 结尾，一路延伸到方案数为 0 为止。容斥易得每个可能只被计算一次。 具体操作就是沿 $A$ 翻了之后再把这个**翻过的点**沿 $B$ 翻，再把这个**翻过的点**沿 $A$ 翻，重复这个过程。翻 $A$ 翻 $B$ 后结尾一定是 $BA$ 或 $BAB$，就相当于刚才结论的推广。 $B$ 开头的也是一样的，先翻 $B$ 就行。 预处理阶乘 $\cal O(n)$，单次询问这个翻折次数大概是 $\cal O(\log n)$。 注：一个点 $(x, y)$ 沿 $A$ 翻得到的新坐标为 $(y - 1, x + 1)$，沿 $B$ 翻得到 $(y + m + 2, x - m - 2)$。 # Code 注意这里的 `maxN` 开大了十倍。 ```cpp #include #include using namespace std; typedef long long LL; const int maxN = 3e7 + 5; const int mod = 1e9 + 7; int n, m, ans; int fac[maxN], inv[maxN]; int QPow(int bas, int ind) { if (ind == -1) return QPow(bas, mod - 2); if (bas == 0 or bas == 1) return bas; int res = 1; while (ind) { if (ind & 1) res = (LL)res * bas % mod; bas = (LL)bas * bas % mod; ind >>= 1; } return res; } inline void Mod(int& x) { x >= mod ? x -= mod : x < 0 ? x += mod : 0; } inline int C(int n, int m) { if (n < 0 or m < 0 or m > n) return 0; return (LL)fac[n] * inv[m] % mod * inv[n - m] % mod; } void Init(int n) { fac[0] = inv[0] = 1; for (int i = 1; i > n >> m; Init((n < 1) + m + 1); int x = n + m + 1, y = n, tag = 0; while (C(x + y, y)) { if (tag) { Mod(ans -= C(x + y, y)); swap(x, y); x += m + 2, y -= m + 2; } else { Mod(ans += C(x + y, y)); swap(x, y); --x, ++y; } tag ^= 1; } x = n + m + 1, y = n, tag = 0; while (C(x + y, y)) { if (tag) { Mod(ans -= C(x + y, y)); swap(x, y); --x, ++y; } else { Mod(ans += C(x + y, y)); swap(x, y); x += m + 2, y -= m + 2; } tag ^= 1; } Mod(ans -= C(n + m + 1 + n, n)); cout < ans < endl; return 0; } ```]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>容斥</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1017G]The Tree]]></title>
    <url>%2Fblog%2FCF1017G-The-Tree%2F</url>
    <content type="text"><![CDATA[--- title: '[CF1017G]The Tree' date: 2019-08-29 14:03:26 tags: [树剖, 线段树] categories: solution password: --- # Description ![](/uploads/pic/asd.png) $$ 1 \le n, m \le 2 \times 10 ^5 $$ # Solution 暴力染色不太好维护。考虑如何查询一个节点是否被染色，如果把 1 这个染色操作视作单点加 1，那么如果存在一个祖先（包含 $x$），其到 $x$ 的路径权值和大于等于路径长度，那么 $x$ 便被染色。 于是便有了一个思路：把路径长度设为负的，也就是初始把所有点权视为 -1，然后查询就直接查询根到 $x$ 的所有后缀和的最大值是否 $\ge 0$ 即可。 （前缀指根到 $x$，后缀指 $x$ 到根） 树直接想怎么维护所有后缀和的最大值可能不直观，丢到序列上就很好想：一个区间的后缀最大值为 左区间的后缀最大值 + 右区间权值和，右区间后缀最大值 这两个值中大的那个。于是线段树维护，查询直接对那 $\log$ 个区间按上面这个方法从右往左合并。 在树上也是一样的，树剖提区间。因为是从 $x$ 往根跳，所以区间默认从右往左，直接合并就行。 考虑怎样在当前这个思路下正确维护 2 操作。首先肯定得区间覆盖为 -1，还得让**覆盖操作之后**子树内所有节点到根的后缀和最大值为 -1，而子树内所有节点的后缀路径要么不包含 $x$，此时肯定后缀最大值是他自己到他自己的路径，值为 -1；要么包含 $x$，这个有可能不对（因为有上面节点的影响），所以直接在覆盖之后查 $x$ 的后缀和最大值，给 $x$ 单点加这个 `-(查到的值 + 1)` 即可，这样就能确保所有节点到根的后缀和最大值为 -1 了。 一定得注意合并顺序。 # Code 指针警告:D ```cpp /********************************************************** * Author : EndSaH * Email : hjxhb1@gmail.com * Created Time : 2019-08-16 14:21 * FileName : bigbro.cpp * Website : https://endsah.cf * *******************************************************/ #include #include #include typedef std::pair pii; #define fir first #define sec second #define debug(...) fprintf(stderr, __VA_ARGS__) #define Debug(s) debug("The message in line %d, Function %s: %s\n", __LINE__, __FUNCTION__, s) #define getchar() (ipos == iend and (iend = (ipos = _ibuf) + fread(_ibuf, 1, __bufsize, stdin), ipos == iend) ? EOF : *ipos++) #define putchar(ch) (opos == oend ? fwrite(_obuf, 1, __bufsize, stdout), opos = _obuf : 0, *opos++ = (ch)) #define __bufsize (1 < 21 | 1) char _ibuf[__bufsize], _obuf[__bufsize], _stk[50]; char *ipos = _ibuf, *iend = _ibuf, *opos = _obuf, *oend = _obuf + __bufsize, *stkpos = _stk; struct END { ~END() { fwrite(_obuf, 1, opos - _obuf, stdout); } } __; inline int read() { register int x = 0; register char ch; while (!isdigit(ch = getchar())); while (x = (x < 3) + (x < 1) + (ch & 15), isdigit(ch = getchar())); return x; } template info = pii(this->l - this->r - 1, -1); } void Pushup() { this->info = Merge(this->lson->info, this->rson->info); } void Pushdown() { if (this->tag) this->lson->Cover(), this->rson->Cover(), this->tag = false; } }; inline ptr New(int l, int r) { static ptr mempool = new Node[n < 2]; return new(mempool++) Node(l, r); } void Build(int l, int r, ptr& cur = root) { cur = New(l, r); if (l == r) { cur->info = pii(-1, -1); return; } int mid = (l + r) >> 1; Build(l, mid, cur->lson), Build(mid + 1, r, cur->rson); cur->Pushup(); } void Add(int pos, int addval, ptr cur = root) { if (cur->l == cur->r) { cur->info = pii(cur->info.fir + addval, cur->info.sec + addval); return; } cur->Pushdown(); int mid = (cur->l + cur->r) >> 1; if (pos rson); cur->Pushup(); } pii Query(int ql, int qr, ptr cur = root) { if (ql l and cur->r info; cur->Pushdown(); pii res(0, -1e9); int mid = (cur->l + cur->r) >> 1; if (mid < qr) res = Merge(Query(ql, qr, cur->rson), res); if (ql lson), res); return res; } void Cover(int ql, int qr, ptr cur = root) { if (ql l and cur->r Cover(); return; } if (ql > cur->r or qr < cur->l) return; cur->Pushdown(); Cover(ql, qr, cur->lson), Cover(ql, qr, cur->rson); cur->Pushup(); } } void DFS1(int u) { size[u] = 1; for (int v : G[u]) if (v != fa[u]) { DFS1(v); size[u] += size[v]; if (size[v] > size[son[u]]) son[u] = v; } } void DFS2(int u) { dfn[u] = ++dfst; if (son[u]) top[son[u]] = top[u], DFS2(son[u]); for (int v : G[u]) if (!top[v]) top[v] = v, DFS2(v); } inline int Query(int x) { pii res(0, -1e9); while (top[x] != 1) { res = Merge(SEG::Query(dfn[top[x]], dfn[x]), res); x = fa[top[x]]; } res = Merge(SEG::Query(1, dfn[x]), res); return res.sec; } int main() { #ifndef ONLINE_JUDGE freopen("bigbro.in", "r", stdin); freopen("bigbro.out", "w", stdout); #endif n = read(), m = read(); for (int i = 2; i = 0 ? "Yes" : "No"); break; } } return 0; } ```]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>树剖</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[uoj61]怎样更有力气]]></title>
    <url>%2Fblog%2Fuoj61-%E6%80%8E%E6%A0%B7%E6%9B%B4%E6%9C%89%E5%8A%9B%E6%B0%94%2F</url>
    <content type="text"><![CDATA[--- title: '[uoj61]怎样更有力气' date: 2019-08-29 14:02:40 tags: MST password: categories: solution --- # Description [link](http://uoj.ac/problem/61) 给定一棵 $n$ 个节点的树，有 $m$ 天修路。每一天修一条路的花费固定，为 $w _i(1 \le i \le m)$。第 $i$ 天会指定两个点 $u, v$，在第 $i$ 天时只可以在树中 $u$ 到 $v$ 的链上的任意两点之间修路。同时还有 $p$ 条限制 $(t, a, b)$，表示第 $t$ 天不能在 $a, b$ 之间修路。问最小生成树的总花费。保证无自环重边，$a, b$ 在 $u _t, v _t$ 的路径上，且一定有一个合法生成树。 $$ 1 \le n, m, p \le 3 \times 10 ^5 \\\\ 1 \le w _i \le 10 ^9 $$ # Solution 采用 Kruskal。把天数按 $w _i$ 从小到大排序，那么每天都是让**能连的边尽量连**。 暴力连略，考虑怎么优化这个连边的过程。 有一个小 trick: 设 $k$ 为当天限制的个数，如果 $k < dis(u, v)$，那么 $u$ 到 $v$ 的这条链上的点一定会被并到一个联通块里去。 可以尝试感性理解，如果要理性证明大概是这样： 容易得到 $u, v$ 之间的距离 $d$。 如果 $k < d$ 且最终 $u$ 到 $v$ 的这条链分成了两个联通块，那么枚举联通块大小 $x$ 可以得到连的边数不超过 $ \binom{x}{2} + \binom{d - x + 1}{2}$。展开得到对于 $\forall x \in [1, d)$，其与 ${d + 1}\choose 2$ 的差值大于 $d$，也就是说限制数超过了 $d$。这与 $k < d$ 矛盾。 所以当 $k < d$ 时可以直接链并，总复杂度 $O(n \log n)$。具体是用并查集，每次找到当前点与其联通的最深的父亲 $fa$，若 $fa$ 深度大于 lca 深度，则尝试将 $fa$ 与 $fa$ 的父亲合并。由于固定连边方向，并查集复杂度为 $O(\log n)$ 而非 $O(\alpha(n))$。 可能你会问：如果 $fa$ 与其父亲有限制边怎么办？ 注意前面说了**链上的点一定会被合并到一个联通块里**。所以这个合并是代表联通块的合并，实际上是连哪两个点并不需要知道。 考虑当 $k \ge d$ 时怎么办。这时可以把 $u$ 到 $v$ 链上的点全部扒下来考虑，因为 $d \le k$ 且 $\sum k = p$，所以扒下来的总点数不超过 $p$，没有问题。 这时把限制抽象成图，可以得到一张 $d + 1$ 个点 $k$ 条边的无向图。这是可连边的图的补图。 注意是对于每一天都有一个限制图，在下文中请将连边与连限制边区分开。 有一个经典结论，一个无向图中最小的点的度数是 $O(\sqrt m)$ 的。 证明也很简单：设其最小度数为 $d$，那么有 $d \le \frac {2m} n, d < n$。$\therefore d ^2 < dn \le 2m$。 于是把这个限制图上的最小度数的点 $x$ 拿出来，与它连限制边的那些点记为集合 $T$，$T$ 的补集记为 $S$。 $S$ 包含了 $x$ 以及没有与 $x$ 有限制边相连的点，那些点直接与 $x$ 并成一个联通块就行了。（相当于考虑了 $S \to S$ 的边） 现在考虑 $T$。显然只有两种连边方式：$T \to T, S \to T$。 $T \to T$：对于 $x$ 暴力枚举与其有限制边相连的两个点，并判断这两点是否有限制边。无则合并。实现上的问题等下说。 $S \to T$：对于 $T$ 中的每一个点枚举与其有限制边相连的点并打上标记。这样很容易得到与其连限制边的且是 $S$ 集合中的点有多少个。如果个数与 $S$ 集合大小相等，也就是 $S$ 集合中的点全部与其有限制边相连，无法连边；否则其一定能与 $S$ 中某个点合并，且因为 $S$ 中所有点都与 $x$ 合并，故直接无视限制边与 $x$ 合并。 时间复杂度分别是 $O(\sum deg _y)$ 和 $O(deg _x ^2)$，易知这两部分均是 $O(k)$ 的。合并需要用到并查集，再带上求 lca，所以总复杂度大概是 $O(n\log n + m \log m + p\alpha(n))$。 实现上的几个问题： 1. 对于一个 $T$ 中的点，枚举其限制边打完标记后再枚举 $T$ 中的另一个点判有无标记即可。不需要用 `std::map` 记边。 2. 开两个并查集，分别对应链并和总体（代码中有体现）。链并的只管链并，实际的才是真正的整体并查集。当链并跳链时，将其与其父亲在实际并查集中**尝试**合并（也就是说可能在实际并查集中已经连起来了）。 # Code ```cpp #include #include #include #include #define fir first #define sec second using namespace std; using pii = pair; using LL = long long; const int maxN = 3e5 + 2; int n, m, p; LL ans; int dep[maxN], deg[maxN]; int fa[2][maxN]; // used for union. 0 for chain, 1 for all int size[maxN]; // for all union int F[20][maxN]; vector G[maxN]; bitset T, vis; struct Day { int u, v, w; vector lim; } day[maxN]; int LCA(int u, int v) { if (u == v) return u; if (dep[u] < dep[v]) swap(u, v); for (int i = 19; ~i; --i) if (dep[F[i][u]] >= dep[v]) u = F[i][u]; if (u == v) return u; for (int i = 19; ~i; --i) if (F[i][u] != F[i][v]) u = F[i][u], v = F[i][v]; return F[0][u]; } void DFS(int u) { for (int v : G[u]) dep[v] = dep[u] + 1, DFS(v); } int Find(int i, int x) { return fa[i][x] == x ? x : fa[i][x] = Find(i, fa[i][x]); } inline void Union(int u, int v, int w) { int fu = Find(1, u), fv = Find(1, v); if (fu == fv) return; ans += w; if (size[fu] > size[fv]) swap(fu, fv); fa[1][fu] = fv; } inline bool Chkmin(int& x, int y) { return x > y ? x = y, true : false; } void Union_for_chain(int u, int lim, int w) // lim lca { for (u = Find(0, u); dep[u] > dep[lim]; u = Find(0, F[0][u])) { int fu = F[0][u]; Union(u, fu, w); fa[0][u] = Find(0, fu); } } // 0 for chain, 1 for all void Input() { cin >> n >> m >> p; for (int i = 2; i > F[0][i]; G[F[0][i]].push_back(i); } for (int i = 1; i > o.u >> o.v >> o.w; } for (int i = 1; i > t >> u >> v; day[t].lim.emplace_back(u, v); } } void Init() { for (int i = 1; i]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world]]></title>
    <url>%2Fblog%2Fhello-world%2F</url>
    <content type="text"><![CDATA[--- title: Hello world date: 2019-08-28 20:18:57 categories: diary --- # Hello world! 之前实在太懒了。重新搭了一遍博客，更新了更多更有价值的文章。 Welcome! ~~咕咕咕~~ # Code ```cpp #include int main(int argc, char** argv) { std::cout < "Hello world!" < std::endl; } ```]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
</search>
